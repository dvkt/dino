DATA:
source.file         is text
source.code         is text
source.length       is number
source.lines        is text vector
source.lines.length is number

reader.ci    is number # current character index 
reader.char  is text   # current character
reader.prev  is text   # previous character
reader.tok   is text   # current token 
reader.line  is text   # current line 
reader.text? is number # boolean

line.tokens        is text vector
line.tokens.length is number
line.number        is number 

eval.state   is number # 1=data, 2=procedure
eval.line    is text
eval.i       is number
eval.first   is text # first char, to check for comments

eval.token          is text
eval.token.type     is number #1=n,2=t,3=var,4=?,5=crlf
eval.token.char     is text
eval.token.number   is number 
eval.token.text     is text
eval.token.variable is text

text.strip-quotes.in  is text
text.strip-quotes.out is text
text.strip-quotes.i   is number
text.strip-quotes.len is number
text.strip-quotes.c   is text
  
variable.types        is number vector #1=n,2=t,3=nv,4=tv
variable.type         is number 
variable.tvalues      is text vector
variable.nvalues      is number vector
variable.name         is text 
variable.names        is text vector
variable.names.length is number

error.msg is text
error.i   is number

PROCEDURE:
# IN: error.msg is text (optional)
sub-procedure error
    display "\e[1;33mlines: \e[0m" source.lines.length crlf 
    display "\e[1;33mline: \e[0m" reader.line crlf 
    display "\e[1;33mline tokens: \e[0m" line.tokens.length crlf 
    display "\e[1;33mtokens: \e[0m" 
    while error.i is less than line.tokens.length do 
        display "\e[32;1m<\e[0m" line.tokens:error.i "\e[32;1m>\e[0m "
        add 1 and error.i in error.i
    repeat
    display "\e[0m" crlf

    display "\e[1;33menv: \e[0m" crlf
    store 0 in error.i
    while error.i is less than variable.names.length do 
        store variable.names:error.i in variable.name
        store variable.types:variable.name in variable.type
        display "* \e[0;1m" variable.name "(" variable.type "): \e[0m" 
        if variable.types:variable.name is equal to 1 then 
            display variable.tvalues:variable.name
        else if variable.types:variable.name is equal to 2 then
            display variable.nvalues:variable.name
        end if 
        display crlf

        add 1 and error.i in error.i
    repeat
    
    if error.msg is equal to "" then 
        store "Malformed statement" in error.msg
    end if 
    display "\e[1;31mLDPL Error: " error.msg " (\e[0m" source.file ":" line.number "\e[1;31m)\e[0m" crlf
    exit
end sub-procedure

#  IN: text.strip-quotes.in
# OUT: text.strip-quotes.out
sub-procedure text.strip-quotes
    # check if first char is a quote
    get character at 0 from text.strip-quotes.in in text.strip-quotes.c
    if text.strip-quotes.c is not equal to "\"" then 
        store text.strip-quotes.in in text.strip-quotes.out
        return
    end if

    # check if last char is a quote
    store length of text.strip-quotes.in in text.strip-quotes.len
    subtract 1 from text.strip-quotes.len in text.strip-quotes.len
    get character at text.strip-quotes.len from text.strip-quotes.in in text.strip-quotes.c
    if text.strip-quotes.c is not equal to "\"" then 
        store text.strip-quotes.in in text.strip-quotes.out
        return
    end if

    # strip quotes
    store "" in text.strip-quotes.out
    store 1 in text.strip-quotes.i     
    while text.strip-quotes.i is less than text.strip-quotes.len do 
        get character at text.strip-quotes.i from text.strip-quotes.in in text.strip-quotes.c
        join text.strip-quotes.out and text.strip-quotes.c in text.strip-quotes.out
        add 1 and text.strip-quotes.i in text.strip-quotes.i
    repeat
end sub-procedure

# Convert text token to literal value or, if it's variable, the 
# variable's value. 
#  IN: eval.token is text
# OUT: eval.token.type 
#      eval.token.text OR eval.token.number
sub-procedure eval.token-to-value
    get character at 0 from eval.token in eval.token.char

    if eval.token is equal to "CRLF" then 
        store 1 in eval.token.type
        store "\n" in eval.token.text
    else if eval.token.char is equal to "\"" then 
        store 1 in eval.token.type
        store eval.token in eval.token.text
    else
        # check for literal number
        store eval.token.char in is-digit.in
        call is-digit
        if is-digit.out is equal to 1 then 
            store 2 in eval.token.type
            store eval.token in eval.token.number
            return 
        end if
            
        # assume variable
        if variable.types:eval.token is greater than 0 then 
            store variable.types:eval.token in eval.token.type
            if eval.token.type is equal to 1 then 
                store variable.tvalues:eval.token in eval.token.text
            else if eval.token.type is equal to 2 then 
                store variable.tvalues:eval.token in eval.token.number
            else 
                call error
            end if
        else 
            call error
        end if
    end if
end sub-procedure

# DISPLAY $...
#  IN: line.tokens
#      line.tokens.length
sub-procedure eval.display
    store 1 in eval.i
    while eval.i is less than line.tokens.length do 
        store line.tokens:eval.i in eval.token
        call eval.token-to-value
        if eval.token.type is equal to 1 then 
            store eval.token.text in text.strip-quotes.in 
            call text.strip-quotes
            display text.strip-quotes.out
        else if eval.token.type is equal to 2 then 
            display eval.token.number
        else if eval.token.type is equal to 3 then
            store eval.token.text in text.strip-quotes.in 
            call text.strip-quotes
            display text.strip-quotes.out
        else if eval.token.type is equal to 4 then
            display eval.token.number
        end if
        add 1 and eval.i in eval.i
    repeat     
end sub-procedure

# STORE $1 IN $3
#  IN: line.tokens
#      line.tokens.length
sub-procedure eval.store
    store line.tokens:1 in eval.token
    call eval.token-to-value
    store line.tokens:3 in variable.name

    if eval.token.type is equal to 1 then 
        store eval.token.text in variable.tvalues:variable.name
    else if eval.token.type is equal to 2 then 
        store eval.token.text in variable.nvalues:variable.name
    else 
        call error 
    end if 
end sub-procedure

# evaluate line in PROCEDURE: section
#  IN: line.tokens
#      eval.line
sub-procedure eval.code-line
    if line.tokens:0 is equal to "DISPLAY" then
        call eval.display
    else if line.tokens:0 is equal to "STORE" then 
        call eval.store
    else
        in error.msg join "Unknown statement: " eval.line
        call error 
    end if
end sub-procedure

# evaluate line in DATA: section
#  IN: line.tokens
sub-procedure eval.data-line
    if line.tokens:1 is equal to "IS" then 
        store line.tokens:0 in variable.name

        # track used variable names for reflection
        store variable.name in variable.names:variable.names.length
        add 1 and variable.names.length in variable.names.length

        if line.tokens:2 is equal to "TEXT" then 
            if line.tokens:3 is equal to "VECTOR" then 
                store 3 in variable.types:variable.name
            else
                store 1 in variable.types:variable.name
            end if
            return
        else if line.tokens:2 is equal to "NUMBER" then
            if line.tokens:3 is equal to "VECTOR" then 
                store 4 in variable.types:variable.name
            else
                store 2 in variable.types:variable.name
            end if

            return
        end if 
    end if 

    in error.msg join "Unknown statement: " eval.line
    call error 
end sub-procedure

# evaluate single line of LDPL code
#  IN: line.tokens
#      line.tokens.length
sub-procedure eval.line
    # ignore empty lines
    if line.tokens.length is equal to 0 then 
        return
    end if 

    # ignore lines that start with comments
    get character at 0 from line.tokens:0 in eval.first
    if eval.first is equal to "#" then 
        return
    end if 

    if line.tokens:0 is equal to "DATA:" then
        if line.tokens.length is greater than 1 then 
            call error 
        end if 
        store 1 in eval.state
    else if line.tokens:0 is equal to "PROCEDURE:" then 
        if line.tokens.length is greater than 1 then 
            call error 
        end if 
        store 2 in eval.state 
    else if eval.state is equal to 1 then 
        call eval.data-line
    else if eval.state is equal to 2 then 
        call eval.code-line
    else 
        in error.msg join "Unknown state: " eval.state
        call error 
    end if
end sub-procedure

#  IN: argv
sub-procedure main   
    store argv:0 in source.file
    load file argv:0 in source.code
    store length of source.code in source.length
    while reader.ci is less than source.length do 
        store reader.char in reader.prev
        get character at reader.ci from source.code in reader.char

        if reader.char is equal to "\n" then 
            # first line is line 1 
            add 1 and line.number in line.number

            # store current token in tokens vector
            if reader.tok is not equal to "" then 
                store reader.tok in line.tokens:line.tokens.length
                add 1 and line.tokens.length in line.tokens.length
                store "" in reader.tok
            end if
            
            # store line in lines vector
            store reader.line in source.lines:source.lines.length
            add 1 and source.lines.length in source.lines.length

            # eval line
            store reader.line in eval.line 
            call eval.line

            # reset line
            store "" in reader.line
            store 0 in line.tokens.length
        else if reader.char is equal to " " then
            # store space in line
            join reader.line and reader.char in reader.line

            if reader.text? is equal to 0 then 
                # store current token in tokens vector
                if reader.tok is not equal to "" then 
                    store reader.tok in line.tokens:line.tokens.length
                    add 1 and line.tokens.length in line.tokens.length
                    store "" in reader.tok
                end if 
            else 
                # store string verbatum 
                join reader.tok and reader.char in reader.tok
            end if
        else if reader.char is equal to "\"" then 
            if reader.prev is not equal to "\\" then 
                if reader.text? is equal to 0 then 
                    # open string 
                    store 1 in reader.text?
                else 
                    # close string
                    store 0 in reader.text?
                end if 
            end if 

            join reader.tok and reader.char in reader.tok
            join reader.line and reader.char in reader.line
        else 
            # don't upcase text
            if reader.text? is equal to 0 then
                # upcase letter
                store reader.char in upcase.letter
                call upcase-letter 
                store upcase.letter in reader.char 
            end if

            # store char in current token 
            join reader.tok and reader.char in reader.tok

            # store char in current line
            join reader.line and reader.char in reader.line
        end if 

        # increment reader counter
        add 1 and reader.ci in reader.ci
    repeat
end sub-procedure

call main
