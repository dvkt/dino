# === CENTRAL PROCESSING UNIT ========================================
# The CPU executes bytecode.
DATA:
cpu.error is text

cpu.operands     is number vector
cpu.operands.len is number
cpu.code is number
cpu.address is number

cpu.stack is number vector
cpu.sp    is number

# --- REGISTERS ------------------------------------------------------
cpu.a  is number
cpu.x  is number
cpu.y  is number
cpu.z  is number
cpu.e  is number
cpu.c  is number
cpu.i  is number
cpu.pc is number
cpu.ta is text
cpu.tx is text
cpu.ty is text
cpu.tz is text
cpu.te is text
cpu.tf is number

PROCEDURE:
sub-procedure cpu.error
    display "\e[1;36m"
    if cpu.pc is less than 10 then
        display 0
    end if
    display cpu.pc " \e[1;31mCPU FAULT: \e[0;1m" cpu.error crlf
    exit
end sub-procedure

# Check bytecode format.
sub-procedure cpu.validate
    store "INVALID BYTECODE FORMAT" in cpu.error
    store 0 in cpu.i
    while cpu.i is less than $OFFSET.CODE do
        if vm.code:cpu.i is not equal to $HEADER:cpu.i then
            call cpu.error
        end if
        add 1 and cpu.i in cpu.i
    repeat
    store "" in cpu.error
end sub-procedure

sub-procedure cpu.run
    call cpu.validate
    store $OFFSET.CODE in cpu.pc
    while cpu.pc is less than vm.code.len do
        store vm.code:cpu.pc in cpu.code

        # skip 0 opcode
        if cpu.code is equal to 0 then
            add 1 and cpu.pc in cpu.pc
            continue
        end if

        # make sure we know about the opcode
        if $NAMES:cpu.code is equal to "" then
            join "BAD OPCODE: " and cpu.code in cpu.error
            call cpu.error
        end if

        if $CODES:"DISPLAY" is equal to cpu.code then
            store 0 in cpu.i
            while cpu.i is less than $SIZES:cpu.code do
                add 1 and cpu.pc in cpu.pc
                if vm.code:cpu.pc is greater than or equal to $OFFSET.TEXT then
                    display vm.text:vm.code:cpu.pc
                else
                    display vm.reg:vm.code:cpu.pc
                end if
                add 1 and cpu.i in cpu.i
            repeat
        else if $CODES:"CALL" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            add 1 and cpu.pc in cpu.stack:cpu.sp
            add 1 and cpu.sp in cpu.sp
            add vm.code:cpu.pc and cpu.pc in cpu.pc
        else if $CODES:"RETURN" is equal to cpu.code then
            subtract 1 from cpu.sp in cpu.sp
            subtract 1 from cpu.stack:cpu.sp in cpu.pc
        else if $CODES:"JUMP" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            add vm.code:cpu.pc and cpu.pc in cpu.pc
        else if $CODES:"JIF" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            if vm.reg:$z is equal to 1 then
                add vm.code:cpu.pc and cpu.pc in cpu.pc
            end if
        else if $CODES:"JIT" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            if vm.reg:$a is equal to 1 then
                add vm.code:cpu.pc and cpu.pc in cpu.pc
            end if
        else if $CODES:"EXIT" is equal to cpu.code then
            exit
        else if $CODES:"ACCEPT" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            if vm.code:cpu.pc is greater than or equal to $OFFSET.TEXT then
                accept vm.text:vm.code:cpu.pc
            else
                accept vm.reg:vm.code:cpu.pc
            end if
        else if $CODES:"STORE" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            store vm.code:cpu.pc in cpu.x
            add 1 and cpu.pc in cpu.pc
            store vm.code:cpu.pc in cpu.y
            if cpu.x is greater than or equal to $OFFSET.TEXT then
                if cpu.y is greater than or equal to $OFFSET.TEXT then
                    store vm.text:vm.code:cpu.x in vm.text:vm.code:cpu.y
                else
                    store vm.text:vm.code:cpu.x in vm.reg:vm.code:cpu.y
                end if
            else
                if cpu.y is greater than or equal to $OFFSET.TEXT then
                    store vm.reg:vm.code:cpu.x in vm.text:vm.code:cpu.y
                else
                    store vm.reg:vm.code:cpu.x in vm.reg:vm.code:cpu.y
                end if
            end if
        else if $CODES:"SET" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            store vm.code:cpu.pc in cpu.i
            add 1 and cpu.pc in cpu.pc
            if cpu.i is greater than or equal to $OFFSET.TEXT then
                subtract $OFFSET.TEXT from cpu.i in cpu.i
                store vm.code:cpu.pc in vm.text:cpu.i
            else
                store vm.code:cpu.pc in vm.reg:cpu.i
            end if
        else if $CODES:"EQ" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            store vm.reg:vm.code:cpu.pc in cpu.x
            add 1 and cpu.pc in cpu.pc
            store vm.reg:vm.code:cpu.pc in cpu.y
            add 1 and cpu.pc in cpu.pc
            if cpu.x is equal to cpu.y then
                store 1 in vm.reg:vm.code:cpu.pc
                store 0 in vm.reg:$z
            else
                store 0 in vm.reg:vm.code:cpu.pc
                store 1 in vm.reg:$z
            end if
        else if $CODES:"GT" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            store vm.reg:vm.code:cpu.pc in cpu.x
            add 1 and cpu.pc in cpu.pc
            store vm.reg:vm.code:cpu.pc in cpu.y
            add 1 and cpu.pc in cpu.pc
            if cpu.x is greater than cpu.y then
                store 1 in vm.reg:vm.code:cpu.pc
                store 0 in vm.reg:$z
            else
                store 0 in vm.reg:vm.code:cpu.pc
                store 1 in vm.reg:$z
            end if
        else if $CODES:"LT" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            store vm.reg:vm.code:cpu.pc in cpu.x
            add 1 and cpu.pc in cpu.pc
            store vm.reg:vm.code:cpu.pc in cpu.y
            add 1 and cpu.pc in cpu.pc
            if cpu.x is less than cpu.y then
                store 1 in vm.reg:vm.code:cpu.pc
                store 0 in vm.reg:$z
            else
                store 0 in vm.reg:vm.code:cpu.pc
                store 1 in vm.reg:$z
            end if
        else if $CODES:"ADD" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            store vm.reg:vm.code:cpu.pc in cpu.x
            add 1 and cpu.pc in cpu.pc
            store vm.reg:vm.code:cpu.pc in cpu.y
            add 1 and cpu.pc in cpu.pc
            add cpu.x and cpu.y in vm.reg:vm.code:cpu.pc
        else if $CODES:"SUB" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            store vm.reg:vm.code:cpu.pc in cpu.x
            add 1 and cpu.pc in cpu.pc
            store vm.reg:vm.code:cpu.pc in cpu.y
            add 1 and cpu.pc in cpu.pc
            subtract cpu.y from cpu.x in vm.reg:vm.code:cpu.pc
        else if $CODES:"MUL" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            store vm.reg:vm.code:cpu.pc in cpu.x
            add 1 and cpu.pc in cpu.pc
            store vm.reg:vm.code:cpu.pc in cpu.y
            add 1 and cpu.pc in cpu.pc
            multiply cpu.x by cpu.y in vm.reg:vm.code:cpu.pc
        else if $CODES:"DIV" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            store vm.reg:vm.code:cpu.pc in cpu.x
            add 1 and cpu.pc in cpu.pc
            store vm.reg:vm.code:cpu.pc in cpu.y
            add 1 and cpu.pc in cpu.pc
            divide cpu.x by cpu.y in vm.reg:vm.code:cpu.pc
        else
            join "UNIMPLEMENTED: " and cpu.code in cpu.error
            in cpu.error join cpu.error " (" $NAMES:cpu.code ") "
            call cpu.error
        end if

        add 1 and cpu.pc in cpu.pc
    repeat
end sub-procedure