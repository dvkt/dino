# === CENTRAL PROCESSING UNIT ========================================
# The CPU executes bytecode.
DATA:
cpu.error        is text
cpu.code         is number
cpu.address      is number

cpu.stack        is number vector
cpu.sp           is number
cpu.pc is number

# Temp vars - not actual registers. That's vm.reg
cpu.a   is number
cpu.x   is number
cpu.y   is number
cpu.i   is number
cpu.t   is text
cpu.tx  is text
cpu.ty  is text

PROCEDURE:
# Print an error and crashes.
#  IN: cpu.error
sub-procedure cpu.error
    display "\e[1;36m"
    if cpu.pc is less than 10 then
        display 0
    end if
    display cpu.pc " \e[1;31mCPU FAULT: \e[0;1m" cpu.error crlf
    exit
end sub-procedure

# Check bytecode format. Crashes if invalid.
#  IN: vm.code
sub-procedure cpu.validate
    store "INVALID BYTECODE FORMAT" in cpu.error
    store 0 in cpu.i
    while cpu.i is less than $OFFSET.CODE do
        if vm.code:cpu.i is not equal to $HEADER:cpu.i then
            call cpu.error
        end if
        add 1 and cpu.i in cpu.i
    repeat
    store "" in cpu.error
end sub-procedure

# Execute bytecode.
#  IN: vm.code(.len)
#      vm.text(.len)
sub-procedure cpu.run
    call cpu.validate
    store $OFFSET.CODE in cpu.pc
    while cpu.pc is less than vm.code.len do
        store vm.code:cpu.pc in cpu.code

        # skip 0 opcode
        if cpu.code is equal to 0 then
            add 1 and cpu.pc in cpu.pc
            continue
        end if

        # make sure we know about the opcode
        if $NAMES:cpu.code is equal to "" then
            join "BAD OPCODE: " and cpu.code in cpu.error
            call cpu.error
        end if

        # --- CONTROL FLOW -------------------------------------------
        if $CODES:"JUMP" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            add vm.code:cpu.pc and cpu.pc in cpu.pc
        else if $CODES:"JIF" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            if vm.reg:$z is equal to 1 then
                add vm.code:cpu.pc and cpu.pc in cpu.pc
            end if
        else if $CODES:"JIT" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            if vm.reg:$a is equal to 1 then
                add vm.code:cpu.pc and cpu.pc in cpu.pc
            end if
        else if $CODES:"CALL" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            add 1 and cpu.pc in cpu.stack:cpu.sp
            add 1 and cpu.sp in cpu.sp
            add vm.code:cpu.pc and cpu.pc in cpu.pc
        else if $CODES:"RETURN" is equal to cpu.code then
            subtract 1 from cpu.sp in cpu.sp
            subtract 1 from cpu.stack:cpu.sp in cpu.pc
        else if $CODES:"EXIT" is equal to cpu.code then
            exit
        else if $CODES:"WAIT" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            wait vm.reg:vm.code:cpu.pc milliseconds

        # --- MEMORY COMMANDS ----------------------------------------
        else if $CODES:"STORE" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            store vm.code:cpu.pc in cpu.x
            add 1 and cpu.pc in cpu.pc
            store vm.code:cpu.pc in cpu.y

            if cpu.x is greater than or equal to $OFFSET.TEXT then
                if cpu.y is greater than or equal to $OFFSET.TEXT then
                    store vm.text:cpu.y in vm.text:cpu.x
                else
                    store vm.reg:cpu.y in vm.text:cpu.x
                end if
            else
                if cpu.y is greater than or equal to $OFFSET.TEXT then
                    store vm.text:cpu.y in vm.reg:cpu.x
                else
                    store vm.reg:cpu.y in vm.reg:cpu.x
                end if
            end if
        else if $CODES:"SET" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            store vm.code:cpu.pc in cpu.x
            add 1 and cpu.pc in cpu.pc
            store vm.code:cpu.pc in cpu.y

            if cpu.y is greater than or equal to $OFFSET.TEXT then
                if cpu.x is greater than or equal to $OFFSET.TEXT then
                    store vm.text:cpu.y in vm.text:cpu.x
                else
                    store vm.text:cpu.y in vm.reg:cpu.x
                end if
            else
                if cpu.x is greater than or equal to $OFFSET.TEXT then
                    store cpu.y in vm.text:cpu.x
                else
                    store cpu.y in vm.reg:cpu.x
                end if
            end if

        # --- ARITHMETIC ---------------------------------------------
        else if $CODES:"EQ" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            store vm.reg:vm.code:cpu.pc in cpu.x
            add 1 and cpu.pc in cpu.pc
            store vm.reg:vm.code:cpu.pc in cpu.y
            add 1 and cpu.pc in cpu.pc
            if cpu.x is equal to cpu.y then
                store 1 in vm.reg:vm.code:cpu.pc
                store 0 in vm.reg:$z
            else
                store 0 in vm.reg:vm.code:cpu.pc
                store 1 in vm.reg:$z
            end if
        else if $CODES:"GT" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            store vm.reg:vm.code:cpu.pc in cpu.x
            add 1 and cpu.pc in cpu.pc
            store vm.reg:vm.code:cpu.pc in cpu.y
            add 1 and cpu.pc in cpu.pc
            if cpu.x is greater than cpu.y then
                store 1 in vm.reg:vm.code:cpu.pc
                store 0 in vm.reg:$z
            else
                store 0 in vm.reg:vm.code:cpu.pc
                store 1 in vm.reg:$z
            end if
        else if $CODES:"LT" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            store vm.reg:vm.code:cpu.pc in cpu.x
            add 1 and cpu.pc in cpu.pc
            store vm.reg:vm.code:cpu.pc in cpu.y
            add 1 and cpu.pc in cpu.pc
            if cpu.x is less than cpu.y then
                store 1 in vm.reg:vm.code:cpu.pc
                store 0 in vm.reg:$z
            else
                store 0 in vm.reg:vm.code:cpu.pc
                store 1 in vm.reg:$z
            end if
        else if $CODES:"ADD" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            store vm.reg:vm.code:cpu.pc in cpu.x
            add 1 and cpu.pc in cpu.pc
            store vm.reg:vm.code:cpu.pc in cpu.y
            add 1 and cpu.pc in cpu.pc
            add cpu.x and cpu.y in vm.reg:vm.code:cpu.pc
        else if $CODES:"SUB" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            store vm.reg:vm.code:cpu.pc in cpu.x
            add 1 and cpu.pc in cpu.pc
            store vm.reg:vm.code:cpu.pc in cpu.y
            add 1 and cpu.pc in cpu.pc
            subtract cpu.y from cpu.x in vm.reg:vm.code:cpu.pc
        else if $CODES:"MUL" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            store vm.reg:vm.code:cpu.pc in cpu.x
            add 1 and cpu.pc in cpu.pc
            store vm.reg:vm.code:cpu.pc in cpu.y
            add 1 and cpu.pc in cpu.pc
            multiply cpu.x by cpu.y in vm.reg:vm.code:cpu.pc
        else if $CODES:"DIV" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            store vm.reg:vm.code:cpu.pc in cpu.x
            add 1 and cpu.pc in cpu.pc
            store vm.reg:vm.code:cpu.pc in cpu.y
            add 1 and cpu.pc in cpu.pc
            divide cpu.x by cpu.y in vm.reg:vm.code:cpu.pc
        else if $CODES:"MOD" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            store vm.reg:vm.code:cpu.pc in cpu.x
            add 1 and cpu.pc in cpu.pc
            store vm.reg:vm.code:cpu.pc in cpu.y
            add 1 and cpu.pc in cpu.pc
            modulo cpu.x by cpu.y in vm.reg:vm.code:cpu.pc
        else if $CODES:"ABS" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            abs vm.reg:vm.code:cpu.pc
        else if $CODES:"CEIL" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            ceil vm.reg:vm.code:cpu.pc
        else if $CODES:"FLOOR" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            floor vm.reg:vm.code:cpu.pc
        else if $CODES:"RANDOM" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            store random in vm.reg:vm.code:cpu.pc

        # --- I/O COMMANDS -------------------------------------------
        else if $CODES:"DISPLAY" is equal to cpu.code then
            store 0 in cpu.i
            while cpu.i is less than $SIZES:cpu.code do
                add 1 and cpu.pc in cpu.pc
                if vm.code:cpu.pc is greater than or equal to $OFFSET.TEXT then
                    display vm.text:vm.code:cpu.pc
                else
                    display vm.reg:vm.code:cpu.pc
                end if
                add 1 and cpu.i in cpu.i
            repeat
        else if $CODES:"ACCEPT" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            if vm.code:cpu.pc is greater than or equal to $OFFSET.TEXT then
                accept vm.text:vm.code:cpu.pc
            else
                accept vm.reg:vm.code:cpu.pc
            end if
        else if $CODES:"EXEC" is equal to cpu.code then
            in cpu.error join "unimplemented:" "EXEC"
            call cpu.error
        else if $CODES:"READ" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            store vm.text:vm.code:cpu.pc in cpu.t
            add 1 and cpu.pc in cpu.pc
            load file cpu.t in vm.text:vm.code:cpu.pc
            store ERRORCODE in vm.reg:$E
            store ERRORTEXT in vm.text:@E
        else if $CODES:"WRITE" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            store vm.text:vm.code:cpu.pc in cpu.t
            add 1 and cpu.pc in cpu.pc
            if vm.code:cpu.pc is greater than or equal to $OFFSET.TEXT then
                write vm.text:vm.code:cpu.pc to file cpu.t
            else
                write vm.reg:vm.code:cpu.pc to file cpu.t
            end if
            store ERRORCODE in vm.reg:$E
            store ERRORTEXT in vm.text:@E
        else if $CODES:"APPEND" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            store vm.text:vm.code:cpu.pc in cpu.t
            add 1 and cpu.pc in cpu.pc
            if vm.code:cpu.pc is greater than or equal to $OFFSET.TEXT then
                append vm.text:vm.code:cpu.pc to file cpu.t
            else
                append vm.reg:vm.code:cpu.pc to file cpu.t
            end if
            store ERRORCODE in vm.reg:$E
            store ERRORTEXT in vm.text:@E

        # --- TEXT OPERATIONS ----------------------------------------
        else if $CODES:"LEN" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            store vm.text:vm.code:cpu.pc in cpu.t
            add 1 and cpu.pc in cpu.pc
            store length of cpu.t in vm.reg:vm.code:cpu.pc
            if vm.reg:$A is equal to 0 then
                store 1 in vm.reg:$Z
            else
                store 0 in vm.reg:$Z
            end if
        else if $CODES:"JOIN" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            store vm.text:vm.code:cpu.pc in cpu.tx
            add 1 and cpu.pc in cpu.pc
            store vm.text:vm.code:cpu.pc in cpu.ty
            add 1 and cpu.pc in cpu.pc
            join cpu.tx and cpu.ty in vm.text:vm.code:cpu.pc
        else if $CODES:"GETC" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            store vm.code:cpu.pc in cpu.x
            add 1 and cpu.pc in cpu.pc
            store vm.text:vm.code:cpu.pc in cpu.t
            add 1 and cpu.pc in cpu.pc
            get character at cpu.x from cpu.t in vm.text:vm.code:cpu.pc
        else if $CODES:"GETCC" is equal to cpu.code then
            add 1 and cpu.pc in cpu.pc
            store vm.text:vm.code:cpu.pc in cpu.t
            add 1 and cpu.pc in cpu.pc
            store character code of cpu.t in vm.reg:vm.code:cpu.pc
            if ERRORCODE is not equal to 0 then
                store 0 in vm.reg:$e
                if vm.reg:vm.code:cpu.pc is equal to 0 then
                    store 1 in vm.reg:$z
                else
                    store 0 in vm.reg:$z
                end if
            else
                store ERRORCODE in vm.reg:$e
                store ERRORTEXT in vm.text:@e
            end if

        else if $CODES:"PUTC" is equal to cpu.code then
            in cpu.error join "unimplemented:" "PUTC"
            call cpu.error

        else
            join "UNIMPLEMENTED: " and cpu.code in cpu.error
            in cpu.error join cpu.error " (" $NAMES:cpu.code ") "
            call cpu.error
        end if


        if $DEBUG is equal to 1 then
            display crlf
            display "\e[1;33m# --- \e[0;1mDEBUG\e[33m -----------------------------------------------------------\e[0m" crlf
            display "\e[1;35mcpu.pc: \e[0;1m" cpu.pc crlf
            display "\e[1;35mopcode: \e[0;1m" cpu.code " " $NAMES:cpu.code crlf
            display "\e[1;35mcpu.a: \e[0;1m" cpu.a crlf
            display "\e[1;35mcpu.x: \e[0;1m" cpu.x crlf
            display "\e[1;35mcpu.y: \e[0;1m" cpu.y crlf
            display "\e[1;35mcpu.i: \e[0;1m" cpu.i crlf
            display "\e[1;35mcpu.t: \e[0;1m" cpu.t crlf
            display "\e[1;33m# --- \e[0;1mREGISTERS\e[33m -------------------------------------------------------\e[0m" crlf
            display "\e[1;35m$a\t\e[0;1m" vm.reg:$a "\t\t"
            display "\e[1;35m@a\t\e[0;1m" vm.text:@a crlf
            display "\e[1;35m$x\t\e[0;1m" vm.reg:$x "\t\t"
            display "\e[1;35m@x\t\e[0;1m" vm.text:@x crlf
            display "\e[1;35m$y\t\e[0;1m" vm.reg:$y "\t\t"
            display "\e[1;35m@y\t\e[0;1m" vm.text:@y crlf
            display "\e[1;35m$z\t\e[0;1m" vm.reg:$z "\t\t"
            display "\e[1;35m@t\t\e[0;1m" vm.text:@t crlf
            display "\e[1;35m$c\t\e[0;1m" vm.reg:$c "\t\t"
            display "\e[1;35m@e\t\e[0;1m" vm.text:@e crlf
            display "\e[1;35m$i\t\e[0;1m" vm.reg:$i crlf
            display "\e[1;35m$t\t\e[0;1m" vm.reg:$t crlf
            display "\e[1;35m$e\t\e[0;1m" vm.reg:$e crlf
            display "\e[1;35m$sp\t\e[0;1m" vm.reg:$sp crlf
            display "\e[1;35m$pc\t\e[0;1m" vm.reg:$pc crlf
            display cpu.pc "> " cpu.code crlf
        end if

        add 1 and cpu.pc in cpu.pc
    repeat
end sub-procedure