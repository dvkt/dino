            *  *__* _*  *  * _*  *__*_ *__*  *
            * |   \(_)_ _  __\ \ / /  \/  |  *
            * | |) | | ' \/ _ \ V /| |\/| |  *
            * |___/|_|_||_\___/\_/ |_|  |_|  *
            *  *  *  *  *  *  *  *  *  *  *  *
                       An LDPL VM
                       Written in
                          LDPL

=== SUMMARY ==========================================================

* Bytecode VM (& Compiler)
* 32 bit words
* 0xFFFF words of memory
* 8 numeric registers (A, X, Y, Z, C, E, SP, PC)
* 5 text registers (TA, TX, TY, TZ, TE)
* Registers, variables, and text share a logical address space.
* Instructions are 1-4 words: One opcode and 0-3 operands.

=== PROJECT STATUS ===================================================

+---+-----------+-----------------------------------------------------
| ? | NAME      | STATUS
+---+-----------+-----------------------------------------------------
| = | ========= | COMPILER ===========================================
|   | Lexer     | Planning
|   | Parser    | Planning
|   | Generator | Planning
|   | Assembler | Working. Need to fix %variables.
| = | ========= | VIRTUAL MACHINE =====================================
|   | CPU       | Design
|   | Memory    | Design
| = | ========= | TOOLING =============================================
|   | REPL      | Planning
|   | Debugger  | Planning
|   | CLI       | Basics

=== ISSUES ===========================================================

1. This first iteration plays fast and loose with the "byte" in
   bytecode. Once LDPL supports bitwise operations we will revisit the
   core design so it's more bit-tastic.

2. We are not considering performance at this time, but rather seeking
   to educate ourselves by creating this friendly dino vm.

=== DESIGN ===========================================================

Each component is a black box, wired together by the three "meta"
components of compiler, vm, and dino. Each component utilizes a set of
IN variables, a set of OUT variables, and a RUN sub-procedure.

- dino
  - compiler
    - lexer
    - parser
    - generator
    - assembler
  - vm
    - memory
    - cpu

=== TODO =============================================================

* [ ] build each part separately
   * [ ] lexer
   * [ ] parser
   * [ ] generator
   * [ ] assembler
   * [ ] loader
   * [ ] memory
   * [ ] cpu
* [x] assembly -> bytecode $ dino bytes examples/99.dino
   * [x] strip comments
   * [x] trim line
   * [x] tokenize file
   * [x] support strings
   * [-] :newline: token  (don't need)
   * [x] accept file from command line
   * [x] tokens -> bytecode
   * [x] print raw bytecode
   * [ ] error checking:
      * [ ] arity
      * [ ] labels?
   * [x] relative jumps
   * [ ] save bytecode to file
* [ ] bytecode -> assembly
   * [x] load bytecode from file
* [ ] VM
   * [x] load bytecode from file
   * [x] run bytecode
   * [ ] Instructions:
      * [x] JUMP
      * [x] JIF
      * [x] JIT
      * [ ] CALL
      * [ ] RETURN
      * [ ] EXIT
      * [ ] WAIT
      * [ ] STORE
      * [x] SET
      * [ ] EQ
      * [x] GT
      * [x] LT
      * [ ] ADD
      * [ ] SUB
      * [ ] MUL
      * [ ] DIV
      * [ ] MOD
      * [ ] ABS
      * [ ] CEIL
      * [ ] FLOOR
      * [ ] RANDOM
      * [ ] PRINT
      * [ ] ACCEPT
      * [ ] EXEC
      * [ ] READ
      * [ ] WRITE
      * [ ] APPEND
      * [ ] LEN
      * [ ] JOIN
      * [ ] GETC
      * [ ] GETCC
      * [ ] PUTC

=== REFERENCE ========================================================

# --- BYTECODE FORMAT ------------------------------------------------
| BYTE | DATA | DESCRIPTION
+------+------+------------------------------------------------------
| 0000 |  76  | First four bytes are char codes for "LDPL"
| 0001 |  68  |
| 0002 |  80  |
| 0003 |  76  |
| 0004 |  01  | Bytecode version number
| 0005 |      | First instruction
| 0006+|      | Program instructions
| 00XX |  06  | Final EXIT
| 00XX |      | Sub-procedure definitions
| 00XX |      | Text constants

# --- MEMORY LAYOUT --------------------------------------------------
| NUM  | NAME | TYPE | DESCRIPTION
+------+------+------+------------------------------------------------
| ==== | ==== | ==== | REGISTERS =====================================
| 0000 | A    | NUM  | Accumulator
| 0001 | X    | NUM  | Parameter
| 0002 | Y    | NUM  | Parameter
| 0003 | Z    | NUM  | $a = 0?
| 0004 | E    | NUM  | Non-zero error code
| 0005 | C    | NUM  | Carry
| 0006 | I    | NUM  | Incrementor
| 0007 | J    | NUM  | Incrementor
| 0008 | SP   | NUM  | Stack pointer
| 0009 | PC   | NUM  | Program counter
| .... |      | NUM  | Reserved
| 000F |      | NUM  | Reserved
| ==== | ==== | ==== | VARIABLES ====================================
| 0010 |      | NUM  | Number variables
| ...  |      |      |
| 3000 | TA   | TEXT | Text accumulator
| 3001 | TX   | TEXT | Parameter
| 3002 | TY   | TEXT | Parameter
| 3003 | TE   | TEXT | Error message
| 3004 |      | TEXT | Text variables
| ...  |      |      |
| FFFF |      |      | Max address

# --- ADDRESS SYNTAX -------------------------------------------------
| NAME            | SYNTAX
+-----------------+---------------------------------------------------
| Register Name   | $z, $TA
| Num Variable    | %bufsize, %Users
| Label           | print-fn, DISPLAY

# --- INSTRUCTIONS ---------------------------------------------------
| CODE | NAME              | DESCRIPTION
+------+-------------------+------------------------------------------
|  00  | n/a               | n/a
| ==== | ================= | CONTROL FLOW ============================
|  01  | JUMP label        | Jump to location of label
|  02  | JIF label         | Jump to label if $a is 0 (false)
|  03  | JIT label         | Jump to label if $a is 1 (true)
|  04  | CALL label        | Push location on stack and jump to label
|  05  | RETURN            | Pop loc off top of stack and jump to it
|  06  | EXIT              | Exit program
|  07  | WAIT $r           | Pause for milliseconds in register.
| ==== | ================= | MEMORY COMMANDS =========================
|  10  | STORE %var $r     | Store value of register r in variable var.
|  11  | SET $r 3.14       | Set $r to literal number value.
| ==== | ================= | ARITHMETIC ==============================
|  20  | EQ $x $y $a       | Set $a=1 if $x == $y
|  21  | GT $x $y $a       | Set $a=1 if $x > $y
|  22  | LT $x $y $a       | Set $a=1 if $x < $y
|  23  | ADD $x $y $a      | Put sum of registers $x and $y in $a
|  24  | SUB $x $y $a      | Subtract value of $y from $x and put in $a.
|  25  | MUL $x $y $a      | Multiplication
|  26  | DIV $x $y $a      | Division. $e will be set to 1 if $y is 0.
|  27  | MOD $x $y $a      | Modulo
|  28  | ABS $x $a         | Put absolute value of register $x in $a
|  29  | CEIL $x $a        | Ceiling
|  2A  | FLOOR $x $a       | Flooring
|  2B  | RANDOM $a         | Put random number in $a.
| ==== | ================= | I/O COMMANDS ============================
|  30  | DISPLAY $r        | Print content of register $r
|  31  | ACCEPT $a         |
|  32  | EXEC $ta          |
|  33  | READ $ta $tz      |
|  34  | WRITE $ta $tb     |
|  35  | APPEND $ta $tb    |
| ==== | ================  | TEXT OPERATIONS ========================
|  40  | LEN $tx $a        | Get length of string in $tx.
|  41  | JOIN $tx $ty $ta  | Concatenate text in registers into $ta.
|  42  | GETC n %str $ta   | Get character at position n in %str.
|  43  | GETCC n %str $a   | Get character code at n in %str.
|  44  | PUTC $tr n        | Put ascii character with code n into $tr.
