            *  *__* _*  *  * _*  *__*_ *__*  *
            * |   \(_)_ _  __\ \ / /  \/  |  *
            * | |) | | ' \/ _ \ V /| |\/| |  *
            * |___/|_|_||_\___/\_/ |_|  |_|  *
            *  *  *  *  *  *  *  *  *  *  *  *
                       An LDPL VM        
                       Written in
                          LDPL

# --- MEMORY LAYOUT --------------------------------------------------
| NUM  | NAME | TYPE | DESCRIPTION
+------+------+------+------------------------------------------------
| ==== | ==== | ==== | REGISTERS =====================================
| 0000 | A    | NUM  | Accumulator
| 0001 | X    | NUM  | Parameter
| 0002 | Y    | NUM  | Parameter
| 0003 | C    | NUM  | Carry
| 0004 | Z    | NUM  | $a = 0?
| 0005 | GZ   | NUM  | $a > 0?
| 0006 | LZ   | NUM  | $a < 0?
| 0007 | E    | NUM  | Non-zero error code
| 0008 | SP   | NUM  | Stack pointer
| 0009 | PC   | NUM  | Program counter
| 000A | TA   | TEXT | Text accumulator
| 000B | TX   | TEXT | Parameter
| 000C | TY   | TEXT | Parameter
| 000D | TZ   | TEXT | Is TA empty?
| 000E | TE   | TEXT | Error message
| 000F | TF   | TEXT | Unused
| ==== | ==== | ==== | VARIABLES ====================================
| 1000 |      | NUM  | Number variables
| 2000 |      | TEXT | Text variables
| ==== | ==== | ==== | CONSTANTS ====================================
| 3000 |      | TEXT | Text literals 
| ...  |      |      |
| FFFF |      |      | Max address

# --- ADDRESS SYNTAX -------------------------------------------------
| NAME            | SYNTAX
+-----------------+---------------------------------------------------
| Register Name   | $z, $TA
| Register ID     | #0, #15, #A
| Variable Name   | %bufsize, %Users
| Label           | print-fn, DISPLAY
| Number literal  | 3010, 10120, 3.14

# --- OPCODES --------------------------------------------------------
| CODE | NAME              | DESCRIPTION
+------+-------------------+------------------------------------------
|  00  | n/a               | n/a
| ==== | ================= | CONTROL FLOW ============================
|  01  | JUMP label        | Jump to location of label
|  02  | JIF label         | Jump to label if $a is 0 (false)
|  03  | JIT label         | Jump to label if $a is 1 (true)
|  04  | JGZ label         | Jump to label if $a > 0
|  05  | JLZ label         | Jump to label if $a < 0 
|  06  | CALL label        | Push location on stack and jump to label
|  07  | RETURN            | Pop loc off top of stack and jump to it 
|  08  | EXIT              | Exit program
|  09  | WAIT $r           | Pause for n milliseconds.
| ==== | ================= | MEMORY COMMANDS =========================
|  10  | STORE %var $r     | Store value of register r in variable var.
|  11  | STORN $r 3.14     | Store number in register r.
| ==== | ================= | I/O COMMANDS ============================
|  20  | PRINT $r          | Print content of register $r
|  21  | ACCEPT $z         | 
|  22  | EXEC $ta          | 
|  23  | READ $ta $tz      | 
|  24  | WRITE $ta $tb     | 
|  25  | APPEND $ta $tb    |
| ==== | ================= | ARITHMETIC ==============================
|  30  | CMP $x $y $a      | Compare $a and $b, result in $z. -1 0 or 1
|  31  | ADD $x $y $a      | Put sum of registers $a and $b in $z
|  32  | SUB $x $y $a      | Subtract value of $b from $a and put in $z.
|  33  | MUL $x $y $a      | Multiplication
|  34  | DIV $x $y $a      | Division. $e will be set to 1 if $b is 0.
|  35  | MOD $x $y $a      | Modulo
|  36  | ABS $x $a         | Put absolute value of register $a in $z
|  37  | CEIL $x $a        | Ceiling
|  38  | FLOOR $x $a       | Flooring
|  39  | RANDOM $a         | Put random number in $z.
| ==== | ================  | TEXT OPERATIONS ========================
|  40  | LEN $tx $a        | Get length of string in $ta.
|  41  | JOIN $tx $ty $ta  | Concatenate text in registers into $ta.
|  42  | GETC n %str $ta   | Get character at position n in %str. 
|  43  | GETCC n %str $a   | Get character code at n in %str.
|  44  | PUTC $tr n        | Put ascii character with code n into $tr.
