                *  *__* _*  *  * _*  *__*_ *__*  *
                * |   \(_)_ _  __\ \ / /  \/  |  *
                * | |) | | ' \/ _ \ V /| |\/| |  *
                * |___/|_|_||_\___/\_/ |_|  |_|  *
                *  *  *  *  *  *  *  *  *  *  *  *

                           An LDPL VM
                           Written in
                              LDPL

=== INTRODUCTION =====================================================

Dino is an interpreter for the LDPL programming language, written in
LDPL. Because LDPL is a compiled language, Dino's goal is to provide a
lightweight, scriptable version of the language runtime that can be
used to quickly prototype ideas, perform system tasks, or compose
programs in an interactive fashion using a REPL. Dino can also be used
to run LDPL programs on systems which lack a C++11 compiler.

Internally, Dino is organized into three parts: compiler, virtual
machine, and tooling, with the `dino` command line program serving as
the primary means of interacting with the suite.

The compiler translates LDPL source code to DinoASM, Dino's simple
assembly language, then to Dinocode, Dino's bytecode format. The
virtual machine loads bytecode into its memory then performs each
instruction, just like your old Nintendo. Tooling includes the `dino`
command line program for running LDPL programs and using the compiler
suite, the REPL, and `dino dis` for displaying / disassembling
dinocode.

The classic bytecode/VM architecture means Dino could (with changes)
support languages other than LDPL in the future, but for now it's
focused on supporting the full LDPL 3.0.5 specification on Linux,
MacOS, Windows, WebAssembly, and Raspberry Pi.

=== ISSUES ===========================================================

1. This first iteration plays fast and loose with the "byte" in
   bytecode. Once LDPL supports bitwise operations we will revisit the
   core design so it's more bit-tastic.

2. We are not considering performance at this time, but rather seeking
   to educate ourselves by creating this friendly dino vm.

=== COMPILER =========================================================

--- LEXER ------------------------------------------------------------

--- PARSER -----------------------------------------------------------

--- CODE GENERATOR ---------------------------------------------------

--- ASSEMBLER --------------------------------------------------------

=== VIRTUAL MACHINE ==================================================

--- MEMORY -----------------------------------------------------------

* 32 bit words
* 0xFFFF words of memory
* 10 numeric registers (A, X, Y, Z, E, C, I, J, SP, PC)
* Registers, variables, and constants share a logical address space:
* Two types: numeric and text. Address determines type.
--- CENTRAL PROCESSING UNIT ------------------------------------------

* Instructions are 1-4 words: One opcode and 0-3 operands.

=== TOOLING ==========================================================

=== PROJECT STATUS ===================================================

+---+-----------+-----------------------------------------------------
| ? | NAME      | STATUS
+---+-----------+-----------------------------------------------------
|   | ========= | COMPILER ===========================================
|   | Lexer     | Planning
|   | Parser    | Planning
|   | Generator | Planning
| X | Assembler | Mostly Working
|   | ========= | VIRTUAL MACHINE =====================================
| > | CPU       | In progress!
| > | Memory    | In progress!
| = | ========= | TOOLING =============================================
|   | REPL      | Planning
|   | Debugger  | Planning
|   | CLI       | Basics
| X | dis       | Working, basic version

=== TODO =============================================================

* [ ] build each part separately
   * [ ] lexer
   * [ ] parser
   * [ ] generator
   * [ ] assembler
   * [ ] loader
   * [ ] memory
   * [ ] cpu
* [x] assembly -> bytecode $ dino bytes examples/99.dino
   * [x] strip comments
   * [x] trim line
   * [x] tokenize file
   * [x] support strings
   * [-] :newline: token  (don't need)
   * [x] accept file from command line
   * [x] tokens -> bytecode
   * [x] print raw bytecode
   * [ ] error checking:
      * [ ] arity
      * [ ] labels?
   * [x] relative jumps
   * [ ] save bytecode to file
* [x] bytecode -> assembly $ dino dis file.dinocode
   * [x] load bytecode from file
* [ ] VM
   * [x] load bytecode from file
   * [x] run bytecode
   * [ ] Instructions:
      * [x] JUMP
      * [x] JIF
      * [x] JIT
      * [x] CALL
      * [x] RETURN
      * [x] EXIT
      * [x] WAIT
      * [x] STORE
      * [x] SET
      * [x] EQ
      * [x] GT
      * [x] LT
      * [x] ADD
      * [x] SUB
      * [x] MUL
      * [x] DIV
      * [x] MOD
      * [x] ABS
      * [x] CEIL
      * [x] FLOOR
      * [x] RANDOM
      * [x] PRINT
      * [x] ACCEPT
      * [ ] EXEC
      * [x] READ
      * [ ] WRITE
      * [ ] APPEND
      * [ ] LEN
      * [ ] JOIN
      * [ ] GETC
      * [ ] GETCC
      * [ ] PUTC

=== REFERENCE ========================================================

# ----- MEMORY ADDRESSES ---------------------------------------------
| 1ST  | LAST | TYPE | DESCRIPTION
+------+------+---------------------------------------------------
| 0000 | 000F | NUM  | Registers ($x, $y, $a, $pc)
| 0010 | 2FFF | NUM  | Variables (%count, %item-size)
| 3000 | FFFF | TEXT | Variables (@name, @ErrorMessage)

# --- REGISTERS ------------------------------------------------------
| NUM  | NAME | DESCRIPTION
+------+------+------------------------------------------------
| 0000 | $A   | Accumulator
| 0001 | $X   | Parameter
| 0002 | $Y   | Parameter
| 0003 | $Z   | $a = 0?
| 0004 | $E   | Non-zero error code
| 0005 | $C   | Carry
| 0006 | $I   | Incrementor
| 0007 | $T   | Temporary value
| 0008 | $SP  | Stack pointer
| 0009 | $PC  | Program counter
| .... |      | Reserved
| 000F |      | Reserved
| 0010 |      | Number variables
| .... |      |
| 3000 | @A   | Text accumulator
| 3001 | @X   | Text register
| 3002 | @Y   | Text register
| 3003 | @T   | Text register
| 3004 | @E   | Error message
| .... |      | Reserved
| 300F |      | Reserved
| 3010 |      | Text variables
| 4000 |      | Text literals
| .... |      |
| FFFF |      | Final address

# --- BYTECODE FORMAT ------------------------------------------------
| BYTE | DATA | DESCRIPTION
+------+------+------------------------------------------------------
| 0000 |  76  | First four bytes are char codes for "LDPL"
| 0001 |  68  |
| 0002 |  80  |
| 0003 |  76  |
| 0004 |  01  | Bytecode version number
| 0005 |      | First instruction
| 0006+|      | Program instructions
| 00XX |  06  | Final EXIT
| 00XX |      | Sub-procedure definitions
| 00XX |      | Text literals

# --- ADDRESS SYNTAX -------------------------------------------------
| NAME            | SYNTAX
+-----------------+---------------------------------------------------
| Register Name   | $z, $pc
| Number Variable | %bufsize, %Users
| Text Variable   | @name, @City
| Text Literal    | "heya", "LDPL rox!"
| Label           | print-fn, DISPLAY

# --- INSTRUCTIONS ---------------------------------------------------
| CODE | NAME              | DESCRIPTION
+------+-------------------+------------------------------------------
|  00  | n/a               | n/a
| ==== | ================= | CONTROL FLOW ============================
|  01  | JUMP label        | Jump to location of label
|  02  | JIF label         | Jump to label if $a is 0 (false)
|  03  | JIT label         | Jump to label if $a is 1 (true)
|  04  | CALL label        | Push location on stack and jump to label
|  05  | RETURN            | Pop loc off top of stack and jump to it
|  06  | EXIT              | Exit program
|  07  | WAIT $r           | Pause for milliseconds in register.
| ==== | ================= | MEMORY COMMANDS =========================
|  10  | STORE %var $r     | Store value of register r in variable var.
|  11  | SET $r 3.14       | Set $r to literal number value.
| ==== | ================= | ARITHMETIC ==============================
|  21  | GT $x $y $a       | Set $a=1 if $x > $y
|  20  | EQ $x $y $a       | Set $a=1 if $x == $y
|  22  | LT $x $y $a       | Set $a=1 if $x < $y
|  23  | ADD $x $y $a      | Put sum of registers $x and $y in $a
|  24  | SUB $x $y $a      | Subtract value of $y from $x and put in $a.
|  25  | MUL $x $y $a      | Multiplication
|  26  | DIV $x $y $a      | Division. $e will be set to 1 if $y is 0.
|  27  | MOD $x $y $a      | Modulo
|  28  | ABS $x            | Convert $x to its absolute value.
|  29  | CEIL $x           | Round $x to next whole number.
|  2A  | FLOOR $x          | Round $x to previous whole number.
|  2B  | RANDOM $a         | Put random number in $a.
| ==== | ================= | I/O COMMANDS ============================
|  30  | DISPLAY $x        | Print content of register $x
|  31  | ACCEPT $x         |
|  32  | EXEC @x @a        |
|  33  | READ @x @a        | Read file at path @x into @a. Sets $e, @e
|  34  | WRITE @x @a       |
|  35  | APPEND @x @a      |
| ==== | ================  | TEXT OPERATIONS ========================
|  40  | LEN @x $a         | Get length of string in @x.
|  41  | JOIN @x @y @a     | Concatenate text in registers into @a.
|  42  | GETC n @str @a    | Get character at position n in @str.
|  43  | GETCC n @str $a   | Get character code at n in @str.
|  44  | PUTC @a n         | Put ascii character with code n into @a.
