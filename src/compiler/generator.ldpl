# === CODE GENERATOR =================================================
# The generator loops through c.Nodes and emits assembly for each.
# By "emit", we mean it puts it into c.Asm.

DATA:
# shared
gen.key            is text
gen.if-stack       is number vector # open if blocks
gen.if-stack*      is number
gen.ifs            is number
gen.if             is number
gen.else           is number
gen.while-stack    is number vector
gen.while-stack*   is number
gen.whiles         is number
gen.while          is number
gen.out            is text
gen.subs           is text  # sub-procedure definitions
gen.sub?           is number
gen.var            is text

# generator.Run
gen.node is number
gen.node.type is text

# gen.arg.emit
gen.arg is number
gen.arg.type is number
gen.arg.value is text
gen.emit.char is text

gen.nvar is text
gen.nvar.i is number

# gen.op.fetch
gen.op is text   # operation, like ADD
gen.op.fetch is text
gen.op.a is text  # tmpvars
gen.op.b is text
gen.op.c is text
gen.op.t is text
gen.op.syms is text vector

# gen.escape-quotes
gen.escape-quotes is text
gen.escape.i      is number
gen.escape.x      is number
gen.escape.c      is text
gen.escape.t      is text
gen.escape.token  is text
gen.escape.prev   is number
gen.escape.chars  is text vector

# gen.error
gen.error is text

# generator.Run
gen.run.sep is text

PROCEDURE:
store  "GT" in gen.op.syms:">"
store "GTE" in gen.op.syms:">="
store  "LT" in gen.op.syms:"<"
store "LTE" in gen.op.syms:"<="
store  "EQ" in gen.op.syms:"=="

# IN : gen.error
# OUT:
sub-procedure gen.error
    display "CODE GEN ERROR: " gen.error crlf
    exit
end sub-procedure

# turn " into \" within a TEXT
#  IN: gen.escape-quotes
# OUT: gen.escape-quotes
sub-procedure gen.escape-quotes
    store 0 in gen.escape.i
    store 0 in gen.escape.x
    store "" in gen.escape.token
    split gen.escape-quotes by "" in gen.escape.chars
    store gen.escape.chars:0 in gen.escape.c
    while gen.escape.c is not equal to "" do
        if gen.escape.c is equal to "\"" then
            subtract 1 from gen.escape.i in gen.escape.prev
            if gen.escape.chars:gen.escape.prev is equal to "\\" then
                join gen.escape.token and "\\\\" in gen.escape.token
            else
                join gen.escape.token and "\\" in gen.escape.token
            end if
        end if
        join gen.escape.token and gen.escape.c in gen.escape.token
        incr gen.escape.i
        get character at gen.escape.i from gen.escape-quotes in gen.escape.c
    repeat
    store gen.escape.token in gen.escape-quotes
end sub-procedure

# Generate a unique number variable name for use in emitting.
# OUT: gen.nvar
sub-procedure gen.nvar
    join "%var" and gen.nvar.i in gen.nvar
    incr gen.nvar.i
end sub-procedure

# Use `gen.arg` to fill `gen.arg.value` and `gen.arg.type`
#  IN: gen.arg
#  IN: gen.node
# OUT: gen.arg
# OUT: gen.arg.type
sub-procedure gen.arg.fetch
    in gen.key join gen.node ":" gen.arg
    store c.Nodes:gen.key in gen.arg.value
    in gen.key join gen.key ":type"
    store c.Nodes:gen.key in gen.arg.type
end sub-procedure

# Emit correct asm arg type for current node based on `gen.arg`
# IN: gen.arg.num
#     gen.node
#     c.Nodes
sub-procedure gen.arg.emit
    call gen.arg.fetch

    if gen.arg.type is equal to 1 then
        in gen.out join gen.out "%" gen.arg.value
    else if gen.arg.type is equal to 2 then
        in gen.out join gen.out "@" gen.arg.value
    else if gen.arg.type is equal to 3 then
        in gen.out join gen.out "UNIMPLEMENTED: number vector"
        exit
    else if gen.arg.type is equal to 4 then
        in gen.out join gen.out "UNIMPLEMENTED: text vector"
        exit
    else if gen.arg.type is equal to 5 then
        in gen.out join gen.out gen.arg.value
    else if gen.arg.type is equal to 6 then
        in gen.out join gen.out gen.arg.value
    else
        in gen.out join gen.out "bad arg type: " gen.arg.type " for " gen.arg.value crlf
        exit
    end if
end sub-procedure

# emit
sub-procedure gen.arg.emit0
    store 0 in gen.arg
    call gen.arg.emit
end sub-procedure
sub-procedure gen.arg.emit1
    store 1 in gen.arg
    call gen.arg.emit
end sub-procedure
sub-procedure gen.arg.emit2
    store 2 in gen.arg
    call gen.arg.emit
end sub-procedure

# Call gen.arg.fetch and then puts ASM var name into gen.op.fetch.
# Emits a SET first if num literal.
# IN: gen.arg
sub-procedure gen.op.fetch
    call gen.arg.fetch
    if gen.arg.type is equal to $TYPES:"NML" then
        call gen.nvar
        in gen.out join gen.out "\tSET " gen.nvar ", " gen.arg.value crlf
        store gen.nvar in gen.op.fetch
    else if gen.arg.type is equal to $TYPES:"TXL" then
        store gen.arg.value in gen.op.fetch
    else if gen.arg.type is equal to $TYPES:"TXT" then
        join "@" and gen.arg.value in gen.op.fetch
    else if gen.arg.type is equal to $TYPES:"NUM" then
        join "%" and gen.arg.value in gen.op.fetch
    else if gen.arg.type is equal to $TYPES:"LBL" then
        store gen.arg.value in gen.op.fetch
    else if gen.arg.type is equal to $TYPES:"SYM" then
        store gen.arg.value in gen.op.fetch
    else
        join "gen.op.fetch: bad arg type: " and gen.arg.type in gen.error
        call gen.error
    end if
end sub-procedure

# emit an instruction with 1 arg, like CALL
# IN : gen.op    # should be something like CALL or GOTO
sub-procedure gen.op.emit
    store 0 in gen.arg
    call gen.op.fetch
    in gen.out join gen.out "\t" gen.op " " gen.op.fetch
end sub-procedure

# emit an instruction with 2 args, like EXEC
# IN : gen.op    # should be something like EXEC
sub-procedure gen.op.emit-2
    store 0 in gen.arg
    call gen.op.fetch
    store gen.op.fetch in gen.op.a

    store 1 in gen.arg
    call gen.op.fetch
    store gen.op.fetch in gen.op.b

    in gen.out join gen.out "\t" gen.op " " gen.op.a ", " gen.op.b
end sub-procedure

# emit an instruction with 3 args, like GETC
# IN : gen.op    # should be something like GETC
sub-procedure gen.op.emit-3
    store 0 in gen.arg
    call gen.op.fetch
    store gen.op.fetch in gen.op.a
    store 1 in gen.arg
    call gen.op.fetch
    store gen.op.fetch in gen.op.b
    store 2 in gen.arg
    call gen.op.fetch
    store gen.op.fetch in gen.op.c
    in gen.out join gen.out "\t" gen.op " " gen.op.a ", " gen.op.b ", " gen.op.c
end sub-procedure

# emit a math operation with 2 args, like ADD
# IN : gen.op    # should be something like ADD or SUB
sub-procedure gen.op.emit-math-2
    store 0 in gen.arg
    call gen.op.fetch
    store gen.op.fetch in gen.op.a

    store 1 in gen.arg
    call gen.op.fetch
    store gen.op.fetch in gen.op.b

    # make sure to flip the order, since LDPL is "backwards"
    in gen.out join gen.out "\t" gen.op " " gen.op.a ", " gen.op.b ", "
    call gen.arg.emit2
end sub-procedure

# emit a conditional like GT from a WHILE or IF node
# IN : gen.node
# IN : c.Nodes
sub-procedure gen.op.emit-cond
    store 0 in gen.arg
    call gen.op.fetch
    store gen.op.fetch in gen.op.a

    store 1 in gen.arg
    call gen.op.fetch
    store gen.op.fetch in gen.op.t

    store 2 in gen.arg
    call gen.op.fetch
    store gen.op.fetch in gen.op.b

    store gen.op.syms:gen.op.t in gen.op
    if gen.op.t is equal to "!=" then
        store "EQ" in gen.op
        in gen.out join gen.out "\tEQ " gen.op.a ", " gen.op.b ", $a" crlf
        in gen.out join gen.out "\tSET $t, 0" crlf
        store "$a" in gen.op.a
        store "$t" in gen.op.b
    end if
    in gen.out join gen.out "\t" gen.op " " gen.op.a ", " gen.op.b ", $a" crlf
end sub-procedure

# IN: c.Nodes
sub-procedure generator.Run
    store "" in c.Asm
    store 0 in gen.node
    while gen.node is less than c.Nodes* do
        store c.Nodes:gen.node in gen.node.type
        store "" in gen.out

        if "STORE" is equal to gen.node.type then
            store 0 in gen.arg
            call gen.arg.fetch
            if gen.arg.type is equal to $TYPES:"NML" then
                in gen.out join gen.out "\tSET" " "
            else
                in gen.out join gen.out "\tSTORE" " "
            end if
            call gen.arg.emit1
            in gen.out join gen.out ", "
            call gen.arg.emit0
        else if "DISPLAY" is equal to gen.node.type then
            store 0 in gen.arg
            while 0 is less than 1 do
                in gen.key join gen.node ":" gen.arg ":type"
                store c.Nodes:gen.key in gen.arg.type
                if gen.arg.type is equal to 0 then
                    break
                end if
                if gen.arg is greater than 0 then
                    in gen.out join gen.out crlf
                end if
                call gen.op.fetch
                in gen.out join gen.out "\tPRINT " gen.op.fetch
                incr gen.arg
            repeat
        else if "IF" is equal to gen.node.type then
            incr gen.ifs
            incr gen.else
            store gen.ifs in gen.if-stack:gen.if-stack*
            incr gen.if-stack*
            # emit test (GT x y z)
            call gen.op.emit-cond
            # emit jump (JIF end_if_001)
            in gen.out join gen.out "\tJIF end_if_" gen.ifs
        else if "ELSE IF" is equal to gen.node.type then
            decr gen.if-stack*
            store gen.if-stack:gen.if-stack* in gen.if
            in gen.out join gen.out "\tJUMP end_else_" gen.else crlf
            # emit label (end_if_001:)
            in gen.out join gen.out "end_if_" gen.if ":" crlf
            incr gen.ifs
            store gen.ifs in gen.if-stack:gen.if-stack*
            incr gen.if-stack*
            # emit test (GT x y z)
            call gen.op.emit-cond
            # emit jump (JIF end_if_001)
            in gen.out join gen.out "\tJIF end_if_" gen.ifs
        else if "ELSE" is equal to gen.node.type then
            decr gen.if-stack*
            store gen.if-stack:gen.if-stack* in gen.if
            in gen.out join gen.out "\tJUMP end_else_" gen.else crlf
            # emit label (end_if_001:)
            in gen.out join gen.out "end_if_" gen.if ":"
            incr gen.ifs
            store gen.ifs in gen.if-stack:gen.if-stack*
            incr gen.if-stack*
        else if "END IF" is equal to gen.node.type then
            decr gen.if-stack*
            store gen.if-stack:gen.if-stack* in gen.if
            # emit label (end_if_001:)
            in gen.out join gen.out "end_if_" gen.if ":" crlf
            in gen.out join gen.out "end_else_" gen.else ":"
        else if "WHILE" is equal to gen.node.type then
            incr gen.whiles
            store gen.whiles in gen.while-stack:gen.while-stack*
            incr gen.while-stack*
            # emit label (while_001:)
            in gen.out join gen.out "while_" gen.whiles ":" crlf
            # emit test (GT x y z)
            call gen.op.emit-cond
            # emit jump (JIF end_while_001)
            in gen.out join gen.out "\tJIF end_while_" gen.whiles
        else if "REPEAT" is equal to gen.node.type then
            decr gen.while-stack*
            store gen.while-stack:gen.while-stack* in gen.while
            # emit jump (JUMP while_001)
            in gen.out join gen.out "\tJUMP while_" gen.while crlf
            # emit label (end_while_001:)
            in gen.out join gen.out "end_while_" gen.while ":"
        else if "CONTINUE" is equal to gen.node.type then
            subtract 1 from gen.while-stack* in gen.while
            store gen.while-stack:gen.while in gen.while
            in gen.out join gen.out "\tJUMP while_" gen.while
        else if "BREAK" is equal to gen.node.type then
            subtract 1 from gen.while-stack* in gen.while
            store gen.while-stack:gen.while in gen.while
            in gen.out join gen.out "\tJUMP end_while_" gen.while
        else if "SUB-PROCEDURE" is equal to gen.node.type then
            store 1 in gen.sub?
            store 0 in gen.arg
            call gen.arg.fetch
            in gen.out join gen.out gen.arg.value ":"
        else if "END SUB-PROCEDURE" is equal to gen.node.type then
            in gen.subs join gen.subs "\tRETURN\n"
            store 0 in gen.sub?
            store "" in gen.out
        else if "CALL" is equal to gen.node.type then
            store "CALL" in gen.op
            call gen.op.emit
        else if "GOTO" is equal to gen.node.type then
            store "JUMP" in gen.op
            call gen.op.emit
        else if "LABEL" is equal to gen.node.type then
            store 0 in gen.arg
            call gen.arg.fetch
            in gen.out join gen.out gen.arg.value ":"
        else if "WAIT" is equal to gen.node.type then
            store "WAIT" in gen.op
            call gen.op.emit
        else if "RETURN" is equal to gen.node.type then
            join gen.out and "\tRETURN" in gen.out
        else if "EXIT" is equal to gen.node.type then
            join gen.out and "\tEXIT" in gen.out
        else if "ADD" is equal to gen.node.type then
            store "ADD" in gen.op
            call gen.op.emit-math-2
        else if "SUBTRACT" is equal to gen.node.type then
            store "SUB" in gen.op
            call gen.op.emit-math-2
        else if "MULTIPLY" is equal to gen.node.type then
            store "MUL" in gen.op
            call gen.op.emit-math-2
        else if "DIVIDE" is equal to gen.node.type then
            store "DIV" in gen.op
            call gen.op.emit-math-2
        else if "MODULO" is equal to gen.node.type then
            store "MOD" in gen.op
            call gen.op.emit-math-2
        else if "ABS" is equal to gen.node.type then
            store "ABS" in gen.op
            call gen.op.emit
        else if "CEIL" is equal to gen.node.type then
            store "CEIL" in gen.op
            call gen.op.emit
        else if "FLOOR" is equal to gen.node.type then
            store "FLOOR" in gen.op
            call gen.op.emit
        else if "RANDOM" is equal to gen.node.type then
            store "RANDOM" in gen.op
            call gen.op.emit
        else if "INCR" is equal to gen.node.type then
            store "INCR" in gen.op
            call gen.op.emit
        else if "DECR" is equal to gen.node.type then
            store "DECR" in gen.op
            call gen.op.emit
        else if "ACCEPT" is equal to gen.node.type then
            store "ACCEPT" in gen.op
            call gen.op.emit
        else if "ACCEPT UNTIL EOF" is equal to gen.node.type then
            store "ACCEOF" in gen.op
            call gen.op.emit
        else if "EXECUTE" is equal to gen.node.type then
            store "EXEC" in gen.op
            call gen.op.emit
            in gen.out join gen.out ", @a"
        else if "EXEC CODE" is equal to gen.node.type then
            store "EXECC" in gen.op
            call gen.op.emit-2
        else if "EXEC OUT" is equal to gen.node.type then
            store "EXEC" in gen.op
            call gen.op.emit-2
        else if "LOAD" is equal to gen.node.type then
            store "READ" in gen.op
            call gen.op.emit-2
        else if "WRITE" is equal to gen.node.type then
            store "WRITE" in gen.op
            call gen.op.emit-2
        else if "APPEND" is equal to gen.node.type then
            store "APPEND" in gen.op
            call gen.op.emit-2
        else if "LENGTH" is equal to gen.node.type then
            store "LEN" in gen.op
            call gen.op.emit-2
        else if "JOIN" is equal to gen.node.type then
            store "JOIN" in gen.op
            call gen.op.emit-3
        else if "GET" is equal to gen.node.type then
            store "GETC" in gen.op
            call gen.op.emit-3
        else if "CHARACTER CODE" is equal to gen.node.type then
            store "GETCC" in gen.op
            call gen.op.emit-2
        else if "CHARACTER" is equal to gen.node.type then
            store "PUTCC" in gen.op
            call gen.op.emit-2
        else if "IN JOIN" is equal to gen.node.type then
            store 0 in gen.arg
            call gen.op.fetch
            store gen.op.fetch in gen.var
            in gen.out join gen.out "\tSET @A, \"\""
            store 1 in gen.arg
            while 0 is less than 1 do
                in gen.key join gen.node ":" gen.arg ":type"
                store c.Nodes:gen.key in gen.arg.type
                if gen.arg.type is equal to 0 then
                    break
                end if
                if gen.arg is greater than 0 then
                    in gen.out join gen.out crlf
                end if
                call gen.op.fetch
                in gen.out join gen.out "\tJOIN @A, " gen.op.fetch ", @A"
                incr gen.arg
            repeat
                in gen.out join gen.out crlf "\tSTORE " gen.var ", @A"
        else if "QUOTE" is equal to gen.node.type then
            store 0 in gen.arg
            call gen.op.fetch
            store gen.op.fetch in gen.var
            incr gen.arg
            call gen.op.fetch
            store gen.op.fetch in gen.escape-quotes
            call gen.escape-quotes
            in gen.out join gen.out crlf "\tSTORE " gen.var ", \"" gen.escape-quotes "\""
        else
            in gen.out join gen.out "? " gen.node.type
        end if

        incr gen.node
        if gen.out is not equal to "" then
            join gen.out and crlf in gen.out
        end if

        if gen.sub? is equal to 1 then
            join gen.subs and gen.out in gen.subs
        else
            join c.Asm and gen.out in c.Asm
        end if
    repeat

    # wrap it up
    in c.Asm join c.Asm "\tEXIT" crlf crlf gen.subs
end sub-procedure
