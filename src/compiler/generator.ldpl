# === CODE GENERATOR =================================================
# The generator loops through c.Nodes and emits assembly for each.
# By "emit", we mean it puts it into c.Asm.

DATA:
# shared
gen.key is text

# generator.Run
gen.node is number
gen.node.type is text

# gen.arg.emit
gen.arg is number
gen.arg.type is number
gen.arg.value is text
gen.emit.char is text

gen.nvar is text
gen.nvar.i is number

# gen.op.fetch
gen.op is text   # operation, like ADD
gen.op.fetch is text
gen.op.a is text  # tmpvars
gen.op.b is text
gen.op.c is text

# gen.error
gen.error is text

# generator.Run
gen.run.sep is text

PROCEDURE:
# IN : gen.error
# OUT:
sub-procedure gen.error
    display "CODE GEN ERROR: " gen.error crlf
    exit
end sub-procedure

# Generate a unique number variable name for use in emitting.
# OUT: gen.var
sub-procedure gen.nvar
    join "%var" and gen.nvar.i in gen.nvar
    incr gen.nvar.i
end sub-procedure

# Use `gen.arg` to fill `gen.arg.value` and `gen.arg.type`
#  IN: gen.arg
#  IN: gen.node
# OUT: gen.arg
# OUT: gen.arg.type
sub-procedure gen.arg.fetch
    in gen.key join gen.node ":" gen.arg
    store c.Nodes:gen.key in gen.arg.value
    in gen.key join gen.key ":type"
    store c.Nodes:gen.key in gen.arg.type
end sub-procedure

# Emit correct asm arg type for current node based on `gen.arg`
# IN: gen.arg.num
#     gen.node
#     c.Nodes
sub-procedure gen.arg.emit
    call gen.arg.fetch

    if gen.arg.type is equal to 1 then
        in c.Asm join c.Asm "%" gen.arg.value
    else if gen.arg.type is equal to 2 then
        in c.Asm join c.Asm "@" gen.arg.value
    else if gen.arg.type is equal to 3 then
        in c.Asm join c.Asm "UNIMPLEMENTED: number vector"
        exit
    else if gen.arg.type is equal to 4 then
        in c.Asm join c.Asm "UNIMPLEMENTED: text vector"
        exit
    else if gen.arg.type is equal to 5 then
        in c.Asm join c.Asm gen.arg.value
    else if gen.arg.type is equal to 6 then
        in c.Asm join c.Asm gen.arg.value
    else
        in c.Asm join c.Asm "bad arg type: " gen.arg.type " for " gen.arg.value crlf
        exit
    end if

    # number variable
end sub-procedure

# emit
sub-procedure gen.arg.emit0
    store 0 in gen.arg
    call gen.arg.emit
end sub-procedure
sub-procedure gen.arg.emit1
    store 1 in gen.arg
    call gen.arg.emit
end sub-procedure
sub-procedure gen.arg.emit2
    store 2 in gen.arg
    call gen.arg.emit
end sub-procedure

# Call gen.arg.fetch and then puts ASM var name into gen.op.fetch.
# Emits a SET first if num literal.
# IN: gen.arg
sub-procedure gen.op.fetch
    call gen.arg.fetch
    if gen.arg.type is equal to $TYPES:"NML" then
        call gen.nvar
        in c.Asm join c.Asm "SET " gen.nvar ", " gen.arg.value crlf
        store gen.nvar in gen.op.fetch
    else if gen.arg.type is equal to $TYPES:"TXL" then
        store gen.arg.value in gen.op.fetch
    else if gen.arg.type is equal to $TYPES:"TXT" then
        join "@" and gen.arg.value in gen.op.fetch
    else if gen.arg.type is equal to $TYPES:"NUM" then
        join "%" and gen.arg.value in gen.op.fetch
    else if gen.arg.type is equal to $TYPES:"LBL" then
        store gen.arg.value in gen.op.fetch
    else
        join "gen.op.fetch: bad arg type: " and gen.arg.type in gen.error
        call gen.error
    end if
end sub-procedure

# emit an instruction with 1 arg, like CALL
# IN : gen.op    # should be something like CALL or GOTO
sub-procedure gen.op.emit
    store 0 in gen.arg
    call gen.op.fetch
    in c.Asm join c.Asm gen.op " " gen.op.fetch
end sub-procedure

# emit a math operation with 1 arg, like CEIL
# IN : gen.op    # should be something like CEIL or FLOOR
sub-procedure gen.op.emit-math-1
    store 0 in gen.arg
    call gen.op.fetch
    in c.Asm join c.Asm gen.op " " gen.op.fetch
end sub-procedure

# emit a math operation with 2 args, like ADD
# IN : gen.op    # should be something like ADD or SUB
sub-procedure gen.op.emit-math-2
    store 0 in gen.arg
    call gen.op.fetch
    store gen.op.fetch in gen.op.a

    store 1 in gen.arg
    call gen.op.fetch
    store gen.op.fetch in gen.op.b

    # make sure to flip the order, since LDPL is "backwards"
    in c.Asm join c.Asm gen.op " " gen.op.b ", " gen.op.a ", "
    call gen.arg.emit2
end sub-procedure

# IN: c.Nodes
sub-procedure generator.Run
    store "" in c.Asm
    store 0 in gen.node
    while gen.node is less than c.Nodes* do
        store c.Nodes:gen.node in gen.node.type

        if nodes.STORE is equal to gen.node.type then
            store 0 in gen.arg
            call gen.arg.fetch
            if gen.arg.type is equal to $TYPES:"NML" then
                in c.Asm join c.Asm "SET" " "
            else
                in c.Asm join c.Asm "STORE" " "
            end if
            call gen.arg.emit1
            in c.Asm join c.Asm ", "
            call gen.arg.emit0
        else if nodes.DISPLAY is equal to gen.node.type then
            store 0 in gen.arg
            while 0 is less than 1 do
                in gen.key join gen.node ":" gen.arg ":type"
                store c.Nodes:gen.key in gen.arg.type
                if gen.arg.type is equal to 0 then
                    break
                end if
                if gen.arg is greater than 0 then
                    in c.Asm join c.Asm crlf
                end if
                in c.Asm join c.Asm "PRINT "
                call gen.arg.emit
                incr gen.arg
            repeat
        else if "CALL" is equal to gen.node.type then
            store "CALL" in gen.op
            call gen.op.emit
        else if "GOTO" is equal to gen.node.type then
            store "GOTO" in gen.op
            call gen.op.emit
        else if "LABEL" is equal to gen.node.type then
            store "LABEL" in gen.op
            call gen.op.emit
        else if "WAIT" is equal to gen.node.type then
            store "WAIT" in gen.op
            call gen.op.emit
        else if "EXIT" is equal to gen.node.type then
            join c.Asm and "EXIT" in c.Asm
        else if "CONTINUE" is equal to gen.node.type then
            join c.Asm and "CONTINUE" in c.Asm
        else if "BREAK" is equal to gen.node.type then
            join c.Asm and "BREAK" in c.Asm
        else if "ADD" is equal to gen.node.type then
            store "ADD" in gen.op
            call gen.op.emit-math-2
        else if "SUBTRACT" is equal to gen.node.type then
            store "SUB" in gen.op
            call gen.op.emit-math-2
        else if "MULTIPLY" is equal to gen.node.type then
            store "MUL" in gen.op
            call gen.op.emit-math-2
        else if "DIVIDE" is equal to gen.node.type then
            store "DIV" in gen.op
            call gen.op.emit-math-2
        else if "MODULO" is equal to gen.node.type then
            store "MOD" in gen.op
            call gen.op.emit-math-2
        else if "ABS" is equal to gen.node.type then
            store "ABS" in gen.op
            call gen.op.emit-math-1
        else if "CEIL" is equal to gen.node.type then
            store "CEIL" in gen.op
            call gen.op.emit-math-1
        else if "FLOOR" is equal to gen.node.type then
            store "FLOOR" in gen.op
            call gen.op.emit-math-1
        else if "RANDOM" is equal to gen.node.type then
            store "RANDOM" in gen.op
            call gen.op.emit-math-1
        else if "INCR" is equal to gen.node.type then
            store "INCR" in gen.op
            call gen.op.emit-math-1
        else if "DECR" is equal to gen.node.type then
            store "DECR" in gen.op
            call gen.op.emit-math-1
        else
            in c.Asm join c.Asm "? " gen.node.type
        end if

        incr gen.node
        if gen.node is less than c.Nodes* then
            in c.Asm join c.Asm crlf
        end if
    repeat
end sub-procedure
