# === CODE GENERATOR =================================================
# The generator loops through c.Nodes and emits assembly for each.
# By "emit", we mean it puts it into c.Asm.

DATA:
# shared
gen.key          is text
gen.blocks       is number vector # open if/while blocks
gen.blocks*      is number
gen.whiles       is number
gen.while        is number
gen.ifs          is number
gen.if           is number
gen.elses        is number
gen.else         is number

# generator.Run
gen.node is number
gen.node.type is text

# gen.arg.emit
gen.arg is number
gen.arg.type is number
gen.arg.value is text
gen.emit.char is text

gen.nvar is text
gen.nvar.i is number

# gen.op.fetch
gen.op is text   # operation, like ADD
gen.op.fetch is text
gen.op.a is text  # tmpvars
gen.op.b is text
gen.op.c is text
gen.op.t is text
gen.op.syms is text vector

# gen.error
gen.error is text

# generator.Run
gen.run.sep is text

PROCEDURE:
store  "GT" in gen.op.syms:">"
store "GTE" in gen.op.syms:">="
store  "LT" in gen.op.syms:"<"
store "LTE" in gen.op.syms:"<="
store  "EQ" in gen.op.syms:"=="
store "NEQ" in gen.op.syms:"!="

# IN : gen.error
# OUT:
sub-procedure gen.error
    display "CODE GEN ERROR: " gen.error crlf
    exit
end sub-procedure

# Generate a unique number variable name for use in emitting.
# OUT: gen.var
sub-procedure gen.nvar
    join "%var" and gen.nvar.i in gen.nvar
    incr gen.nvar.i
end sub-procedure

# Use `gen.arg` to fill `gen.arg.value` and `gen.arg.type`
#  IN: gen.arg
#  IN: gen.node
# OUT: gen.arg
# OUT: gen.arg.type
sub-procedure gen.arg.fetch
    in gen.key join gen.node ":" gen.arg
    store c.Nodes:gen.key in gen.arg.value
    in gen.key join gen.key ":type"
    store c.Nodes:gen.key in gen.arg.type
end sub-procedure

# Emit correct asm arg type for current node based on `gen.arg`
# IN: gen.arg.num
#     gen.node
#     c.Nodes
sub-procedure gen.arg.emit
    call gen.arg.fetch

    if gen.arg.type is equal to 1 then
        in c.Asm join c.Asm "%" gen.arg.value
    else if gen.arg.type is equal to 2 then
        in c.Asm join c.Asm "@" gen.arg.value
    else if gen.arg.type is equal to 3 then
        in c.Asm join c.Asm "UNIMPLEMENTED: number vector"
        exit
    else if gen.arg.type is equal to 4 then
        in c.Asm join c.Asm "UNIMPLEMENTED: text vector"
        exit
    else if gen.arg.type is equal to 5 then
        in c.Asm join c.Asm gen.arg.value
    else if gen.arg.type is equal to 6 then
        in c.Asm join c.Asm gen.arg.value
    else
        in c.Asm join c.Asm "bad arg type: " gen.arg.type " for " gen.arg.value crlf
        exit
    end if

    # number variable
end sub-procedure

# emit
sub-procedure gen.arg.emit0
    store 0 in gen.arg
    call gen.arg.emit
end sub-procedure
sub-procedure gen.arg.emit1
    store 1 in gen.arg
    call gen.arg.emit
end sub-procedure
sub-procedure gen.arg.emit2
    store 2 in gen.arg
    call gen.arg.emit
end sub-procedure

# Call gen.arg.fetch and then puts ASM var name into gen.op.fetch.
# Emits a SET first if num literal.
# IN: gen.arg
sub-procedure gen.op.fetch
    call gen.arg.fetch
    if gen.arg.type is equal to $TYPES:"NML" then
        call gen.nvar
        in c.Asm join c.Asm "\tSET " gen.nvar ", " gen.arg.value crlf
        store gen.nvar in gen.op.fetch
    else if gen.arg.type is equal to $TYPES:"TXL" then
        store gen.arg.value in gen.op.fetch
    else if gen.arg.type is equal to $TYPES:"TXT" then
        join "@" and gen.arg.value in gen.op.fetch
    else if gen.arg.type is equal to $TYPES:"NUM" then
        join "%" and gen.arg.value in gen.op.fetch
    else if gen.arg.type is equal to $TYPES:"LBL" then
        store gen.arg.value in gen.op.fetch
    else if gen.arg.type is equal to $TYPES:"SYM" then
        store gen.arg.value in gen.op.fetch
    else
        join "gen.op.fetch: bad arg type: " and gen.arg.type in gen.error
        call gen.error
    end if
end sub-procedure

# emit an instruction with 1 arg, like CALL
# IN : gen.op    # should be something like CALL or GOTO
sub-procedure gen.op.emit
    store 0 in gen.arg
    call gen.op.fetch
    in c.Asm join c.Asm "\t" gen.op " " gen.op.fetch
end sub-procedure

# emit a math operation with 1 arg, like CEIL
# IN : gen.op    # should be something like CEIL or FLOOR
sub-procedure gen.op.emit-math-1
    store 0 in gen.arg
    call gen.op.fetch
    in c.Asm join c.Asm "\t" gen.op " " gen.op.fetch
end sub-procedure

# emit a math operation with 2 args, like ADD
# IN : gen.op    # should be something like ADD or SUB
sub-procedure gen.op.emit-math-2
    store 0 in gen.arg
    call gen.op.fetch
    store gen.op.fetch in gen.op.a

    store 1 in gen.arg
    call gen.op.fetch
    store gen.op.fetch in gen.op.b

    # make sure to flip the order, since LDPL is "backwards"
    in c.Asm join c.Asm "\t" gen.op " " gen.op.b ", " gen.op.a ", "
    call gen.arg.emit2
end sub-procedure

# emit a conditional like GT from a WHILE or IF node
# IN : gen.node
# IN : c.Nodes
sub-procedure gen.op.emit-cond
    store 0 in gen.arg
    call gen.op.fetch
    store gen.op.fetch in gen.op.a

    store 1 in gen.arg
    call gen.op.fetch
    store gen.op.fetch in gen.op.t

    store 2 in gen.arg
    call gen.op.fetch
    store gen.op.fetch in gen.op.b

    store gen.op.syms:gen.op.t in gen.op
    in c.Asm join c.Asm "\t" gen.op " " gen.op.a ", " gen.op.b ", $a" crlf
end sub-procedure

# IN: c.Nodes
sub-procedure generator.Run
    store "" in c.Asm
    store 0 in gen.node
    while gen.node is less than c.Nodes* do
        store c.Nodes:gen.node in gen.node.type

        if "STORE" is equal to gen.node.type then
            store 0 in gen.arg
            call gen.arg.fetch
            if gen.arg.type is equal to $TYPES:"NML" then
                in c.Asm join c.Asm "\tSET" " "
            else
                in c.Asm join c.Asm "\tSTORE" " "
            end if
            call gen.arg.emit1
            in c.Asm join c.Asm ", "
            call gen.arg.emit0
        else if "DISPLAY" is equal to gen.node.type then
            store 0 in gen.arg
            while 0 is less than 1 do
                in gen.key join gen.node ":" gen.arg ":type"
                store c.Nodes:gen.key in gen.arg.type
                if gen.arg.type is equal to 0 then
                    break
                end if
                if gen.arg is greater than 0 then
                    in c.Asm join c.Asm crlf
                end if
                in c.Asm join c.Asm "\tPRINT "
                call gen.arg.emit
                incr gen.arg
            repeat
        else if "IF" is equal to gen.node.type then
            incr gen.ifs
            incr gen.else
            store gen.ifs in gen.blocks:gen.blocks*
            incr gen.blocks*
            # emit test (GT x y z)
            call gen.op.emit-cond
            # emit jump (JIF end_if_001)
            in c.Asm join c.Asm "\tJIF end_if_" gen.ifs
        else if "ELSE IF" is equal to gen.node.type then
            decr gen.blocks*
            store gen.blocks:gen.blocks* in gen.if
            in c.Asm join c.Asm "\tJUMP end_else_" gen.else crlf
            # emit label (end_if_001:)
            in c.Asm join c.Asm "end_if_" gen.if ":" crlf
            incr gen.ifs
            store gen.ifs in gen.blocks:gen.blocks*
            incr gen.blocks*
            # emit test (GT x y z)
            call gen.op.emit-cond
            # emit jump (JIF end_if_001)
            in c.Asm join c.Asm "\tJIF end_if_" gen.ifs
        else if "ELSE" is equal to gen.node.type then
            decr gen.blocks*
            store gen.blocks:gen.blocks* in gen.if
            in c.Asm join c.Asm "\tJUMP end_else_" gen.else crlf
            # emit label (end_if_001:)
            in c.Asm join c.Asm "end_if_" gen.if ":"
            incr gen.ifs
            store gen.ifs in gen.blocks:gen.blocks*
            incr gen.blocks*
        else if "END IF" is equal to gen.node.type then
            decr gen.blocks*
            store gen.blocks:gen.blocks* in gen.if
            # emit label (end_if_001:)
            in c.Asm join c.Asm "end_if_" gen.if ":" crlf
            in c.Asm join c.Asm "end_else_" gen.else ":"
            decr gen.else
        else if "WHILE" is equal to gen.node.type then
            incr gen.whiles
            store gen.whiles in gen.blocks:gen.blocks*
            incr gen.blocks*
            # emit label (while_001:)
            in c.Asm join c.Asm "while_" gen.whiles ":" crlf
            # emit test (GT x y z)
            call gen.op.emit-cond
            # emit jump (JIF end_while_001)
            in c.Asm join c.Asm "\tJIF end_while_" gen.whiles
        else if "REPEAT" is equal to gen.node.type then
            decr gen.blocks*
            store gen.blocks:gen.blocks* in gen.while
            # emit jump (JUMP while_001)
            in c.Asm join c.Asm "\tJUMP while_" gen.while crlf
            # emit label (end_while_001:)
            in c.Asm join c.Asm "end_while_" gen.while ":"
        else if "CALL" is equal to gen.node.type then
            store "CALL" in gen.op
            call gen.op.emit
        else if "GOTO" is equal to gen.node.type then
            store "GOTO" in gen.op
            call gen.op.emit
        else if "LABEL" is equal to gen.node.type then
            store "LABEL" in gen.op
            call gen.op.emit
        else if "WAIT" is equal to gen.node.type then
            store "WAIT" in gen.op
            call gen.op.emit
        else if "EXIT" is equal to gen.node.type then
            join c.Asm and "EXIT" in c.Asm
        else if "CONTINUE" is equal to gen.node.type then
            join c.Asm and "CONTINUE" in c.Asm
        else if "BREAK" is equal to gen.node.type then
            join c.Asm and "BREAK" in c.Asm
        else if "ADD" is equal to gen.node.type then
            store "ADD" in gen.op
            call gen.op.emit-math-2
        else if "SUBTRACT" is equal to gen.node.type then
            store "SUB" in gen.op
            call gen.op.emit-math-2
        else if "MULTIPLY" is equal to gen.node.type then
            store "MUL" in gen.op
            call gen.op.emit-math-2
        else if "DIVIDE" is equal to gen.node.type then
            store "DIV" in gen.op
            call gen.op.emit-math-2
        else if "MODULO" is equal to gen.node.type then
            store "MOD" in gen.op
            call gen.op.emit-math-2
        else if "ABS" is equal to gen.node.type then
            store "ABS" in gen.op
            call gen.op.emit-math-1
        else if "CEIL" is equal to gen.node.type then
            store "CEIL" in gen.op
            call gen.op.emit-math-1
        else if "FLOOR" is equal to gen.node.type then
            store "FLOOR" in gen.op
            call gen.op.emit-math-1
        else if "RANDOM" is equal to gen.node.type then
            store "RANDOM" in gen.op
            call gen.op.emit-math-1
        else if "INCR" is equal to gen.node.type then
            store "INCR" in gen.op
            call gen.op.emit-math-1
        else if "DECR" is equal to gen.node.type then
            store "DECR" in gen.op
            call gen.op.emit-math-1
        else
            in c.Asm join c.Asm "? " gen.node.type
        end if

        incr gen.node
        if gen.node is less than c.Nodes* then
            in c.Asm join c.Asm crlf
        end if
    repeat

    # wrap it up
    in c.Asm join c.Asm crlf "\tEXIT"
end sub-procedure
