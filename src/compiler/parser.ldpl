# === PARSER =========================================================
# The parser validates syntax (kinda) and turns a text vector of
# tokens into two vectors: code nodes and variables.
#
# The variables vector, c.Vars, is actually two vectors in one:
#   - Number subindexes give you the name of a variable.
#   - Text subindexes give the variable's $type.
#
# The code vector, cNodes, fakes a struct with the following key
# structure:
#   - $id         # node name
#   - $id:0       # 1st argument
#   - $id:0:type  # 1st argument's $type
#   - $id:1       # 2nd argument...
#   - $id:1:type
# And so on.

DATA:
# OUT:
parser.mode      is number        # 1=data, 2=code
parser.node      is number

parser.run.c     is number        # main iterator
parser.n         is number
parser.i         is number
parser.t         is text
parser.token     is text
parser.char      is text
parser.prev      is number
parser.next      is number
parser.var       is text
parser.key       is text
parser.expect    is text

parser.type      is number
parser.arg       is number

parser.peek      is text
parser.peek.n    is number

parser.error     is text
parser.error.i   is number

PROCEDURE:
# IN: parser.error
sub-procedure parser.error
    display "parser.error: " parser.error crlf
    display "token " parser.run.c " of " c.Tokens* crlf
    while parser.error.i is less than c.Tokens* do
        if parser.error.i is equal to parser.run.c then
            display "\e[33;1m" c.Tokens:parser.error.i "\e[0m "
        else
            display c.Tokens:parser.error.i " "
        end if
        incr parser.error.i
    repeat
    exit
end sub-procedure

# Stores next token in `parser.peek`
#  IN: parser.run.c
# OUT: parser.peek
sub-procedure parser.peek
    add 1 and parser.run.c in parser.peek.n
    store c.Tokens:parser.peek.n in parser.peek
end sub-procedure

# Moves the parser forward by one token, setting parser.token.
#  IN: parser.run.c
# OUT: parser.token
#      parser.prev
sub-procedure parser.advance
    store parser.run.c in parser.prev
    incr parser.run.c
    store c.Tokens:parser.run.c in parser.token
end sub-procedure

# Check if the current token is what we want. Errors if not.
#  IN: parser.expect
#      parser.token
sub-procedure parser.expect
    call parser.advance
    if parser.token is not equal to parser.expect then
        in parser.error join "expected " parser.expect ", got " parser.token crlf
        call parser.error
    end if
end sub-procedure

# Identify the type of `parser.token`
#  IN: parser.token
# OUT: parser.type
sub-procedure parser.type.identify
    get character at 0 from parser.token in parser.char

    # number
    store parser.char in digit?.in
    if parser.char is equal to "-" then
        get character at 1 from parser.token in digit?.in
    end if
    call digit?
    if digit? is equal to 1 then
        store $TYPES:"NML" in parser.type
        return
    end if

    # text
    if parser.char is equal to "\"" then
        store $TYPES:"TXL" in parser.type
        return
    end if

    # variable
    store c.Vars:parser.token in parser.n
    if parser.n is not equal to 0 then
        store parser.n in parser.type
        return
    end if

    # label
    store $TYPES:"LBL" in parser.type
    return

    in parser.error join "can't identify " parser.token
    call parser.error
end sub-procedure

# Turns a conditional like "less than" into a symbol "<" and sticks it
# in c.Nodes:$id:$arg
#  IN: parser.token
#      parser.arg
# OUT: c.Nodes
sub-procedure parser.node.set-cond
    in parser.key join c.Nodes* ":" parser.arg ":type"
    store $TYPES:"SYM" in c.Nodes:parser.key
    in parser.key join c.Nodes* ":" parser.arg

    if parser.token is equal to "EQUAL" then
        store "TO" in parser.expect
        call parser.expect
        call parser.advance
        store "==" in c.Nodes:parser.key
    else if parser.token is equal to "NOT" then
        store "EQUAL" in parser.expect
        call parser.expect
        store "TO" in parser.expect
        call parser.expect
        call parser.advance
        store "!=" in c.Nodes:parser.key
    else if parser.token is equal to "LESS" then
        store "THAN" in parser.expect
        call parser.expect
        if parser.token is equal to "OR" then
            store "OR" in parser.expect
            call parser.expect
            store "EQUAL" in parser.expect
            call parser.expect
            store "TO" in parser.expect
            call parser.expect
            store "<=" in c.Nodes:parser.key
        else
            store "<" in c.Nodes:parser.key
        end if
        call parser.advance
    else if parser.token is equal to "GREATER" then
        store "THAN" in parser.expect
        call parser.expect
        if parser.token is equal to "OR" then
            store "OR" in parser.expect
            call parser.expect
            store "EQUAL" in parser.expect
            call parser.expect
            store "TO" in parser.expect
            call parser.advance
            store ">=" in c.Nodes:parser.key
        else
            store ">" in c.Nodes:parser.key
        end if
        call parser.advance
    else
        join "not a conditional: " and parser.token in parser.error
        call parser.error
    end if
end sub-procedure

# Uses the value of `parser.arg` to set c.Nodes:$id:$arg
sub-procedure parser.node.set
    in parser.key join c.Nodes* ":" parser.arg
    store parser.token in c.Nodes:parser.key
    join parser.key and ":type" in parser.key
    call parser.type.identify
    store parser.type in c.Nodes:parser.key
end sub-procedure

# sets the value of `parser.token` to c.Nodes:$id:0
sub-procedure parser.node.set0
    store 0 in parser.arg
    call parser.node.set
end sub-procedure
sub-procedure parser.node.set1
    store 1 in parser.arg
    call parser.node.set
end sub-procedure
sub-procedure parser.node.set2
    store 2 in parser.arg
    call parser.node.set
end sub-procedure
sub-procedure parser.node.set3
    store 3 in parser.arg
    call parser.node.set
end sub-procedure

# Parse procedure statement and create a node.
#   IN: c.Nodes
#       parser.token
# NODE:
#   * $id       # node type
#   * $id:0
#   * $id:1
#   * $id:2...
sub-procedure parser.node.create
    if parser.token is equal to tokens.NEWLINE then
        return
    end if

    store parser.token in c.Nodes:c.Nodes*
    store 0 in parser.arg

    if "STORE" is equal to parser.token then
        call parser.advance
        if parser.token is equal to "RANDOM" then
            store parser.token in c.Nodes:c.Nodes*
            store "IN" in parser.expect
            call parser.expect
            call parser.advance
            call parser.node.set0
        else if parser.token is equal to "LENGTH" then
            store parser.token in c.Nodes:c.Nodes*
            store "OF" in parser.expect
            call parser.expect
            call parser.advance
            call parser.node.set0
            store "IN" in parser.expect
            call parser.expect
            call parser.advance
            call parser.node.set1
        else if parser.token is equal to "CHARACTER" then
            store parser.token in c.Nodes:c.Nodes*
            call parser.advance
            if parser.token is equal to "CODE" then
                store "CHARACTER CODE" in c.Nodes:c.Nodes*
                store "OF" in parser.expect
                call parser.expect
                call parser.advance
            end if
            call parser.node.set0
            store "IN" in parser.expect
            call parser.expect
            call parser.advance
            call parser.node.set1
        else
            call parser.node.set0
            store "IN" in parser.expect
            call parser.expect
            call parser.advance
            call parser.node.set1
        end if
    else if "DISPLAY" is equal to parser.token then
        call parser.advance
        call parser.node.set0
        # vargs...
        store 1 in parser.arg
        while parser.arg is less than 8 do
            call parser.peek
            if parser.peek is equal to tokens.NEWLINE then
                break
            else if parser.peek is equal to "" then
                break
            else
                call parser.advance
                call parser.node.set
            end if
            incr parser.arg
        repeat
    else if "CALL" is equal to parser.token then
        call parser.advance
        if parser.token is equal to "SUB-PROCEDURE" then
            call parser.advance
        end if
        call parser.node.set0
    else if "ELSE" is equal to parser.token then
        call parser.peek
        if parser.peek is equal to "IF" then
            store "ELSE IF" in c.Nodes:c.Nodes*
            call parser.advance
            call parser.advance
            call parser.node.set0
            store "IS" in parser.expect
            call parser.expect
            call parser.advance
            store 1 in parser.arg
            call parser.node.set-cond
            call parser.node.set2
            store "THEN" in parser.expect
            call parser.expect
        end if
        call parser.advance
    else if "IF" is equal to parser.token then
        call parser.advance
        call parser.node.set0
        store "IS" in parser.expect
        call parser.expect
        call parser.advance
        store 1 in parser.arg
        call parser.node.set-cond
        call parser.node.set2
        store "THEN" in parser.expect
        call parser.expect
        call parser.advance
    else if "SUB-PROCEDURE" is equal to parser.token then
        call parser.advance
        call parser.node.set0
        call parser.advance
    else if "END" is equal to parser.token then
        call parser.peek
        if "SUB-PROCEDURE" is equal to parser.peek then
            store "END SUB-PROCEDURE" in c.Nodes:c.Nodes*
        else if "IF" is equal to parser.peek then
            store "END IF" in c.Nodes:c.Nodes*
        else
            join "unexpected END token: " and parser.token in parser.error
            call parser.error
        end if
        call parser.advance
    else if "WHILE" is equal to parser.token then
        call parser.advance
        call parser.node.set0
        store "IS" in parser.expect
        call parser.expect
        call parser.advance
        store 1 in parser.arg
        call parser.node.set-cond
        call parser.node.set2
        store "DO" in parser.expect
        call parser.expect
        call parser.advance
    else if "REPEAT" is equal to parser.token then
        call parser.advance
    else if "ADD" is equal to parser.token then
        call parser.advance
        call parser.node.set0
        store "AND" in parser.expect
        call parser.expect
        call parser.advance
        call parser.node.set1
        store "IN" in parser.expect
        call parser.expect
        call parser.advance
        call parser.node.set2
    else if "SUBTRACT" is equal to parser.token then
        call parser.advance
        call parser.node.set0
        store "FROM" in parser.expect
        call parser.expect
        call parser.advance
        call parser.node.set1
        store "IN" in parser.expect
        call parser.expect
        call parser.advance
        call parser.node.set2
    else if "MULTIPLY" is equal to parser.token then
        call parser.advance
        call parser.node.set0
        store "BY" in parser.expect
        call parser.expect
        call parser.advance
        call parser.node.set1
        store "IN" in parser.expect
        call parser.expect
        call parser.advance
        call parser.node.set2
    else if "DIVIDE" is equal to parser.token then
        call parser.advance
        call parser.node.set0
        store "BY" in parser.expect
        call parser.expect
        call parser.advance
        call parser.node.set1
        store "IN" in parser.expect
        call parser.expect
        call parser.advance
        call parser.node.set2
    else if "MODULO" is equal to parser.token then
        call parser.advance
        call parser.node.set0
        store "BY" in parser.expect
        call parser.expect
        call parser.advance
        call parser.node.set1
        store "IN" in parser.expect
        call parser.expect
        call parser.advance
        call parser.node.set2
    else if "ABS" is equal to parser.token then
        call parser.advance
        call parser.node.set0
    else if "FLOOR" is equal to parser.token then
        call parser.advance
        call parser.node.set0
    else if "CEIL" is equal to parser.token then
        call parser.advance
        call parser.node.set0
    else if "INCR" is equal to parser.token then
        call parser.advance
        call parser.node.set0
    else if "DECR" is equal to parser.token then
        call parser.advance
        call parser.node.set0
    else if "ACCEPT" is equal to parser.token then
        call parser.advance
        call parser.node.set0
    else if "WAIT" is equal to parser.token then
        call parser.advance
        call parser.node.set0
    else if "EXIT" is equal to parser.token then
        call parser.advance
    else if "CONTINUE" is equal to parser.token then
        call parser.advance
    else if "BREAK" is equal to parser.token then
        call parser.advance
    else if "GOTO" is equal to parser.token then
        call parser.advance
        call parser.node.set0
    else if "LABEL" is equal to parser.token then
        call parser.advance
        call parser.node.set0
    else
        join "unknown token: " and parser.token in parser.error
        call parser.error
    end if

    incr c.Nodes*
end sub-procedure

#  IN: c.Tokens
# OUT: c.Nodes
#      c.Vars
sub-procedure parser.Run
    store 0 in parser.run.c
    store 0 in parser.mode
    store 0 in c.Nodes*
    while parser.run.c is less than c.Tokens* do
        subtract 1 from parser.run.c in parser.prev
        store c.Tokens:parser.run.c in parser.token
        get character at 0 from parser.token in parser.char

        if parser.token is equal to "DATA:" then
            store 1 in parser.mode
        else if parser.token is equal to "PROCEDURE:" then
            store 2 in parser.mode
        else if parser.mode is equal to 1 then # DATA: section
            if parser.token is equal to tokens.NEWLINE then
                incr parser.run.c
                continue
            end if
            store parser.token in c.Vars:c.Vars*
            store parser.token in parser.var
            call parser.advance
            if parser.token is not equal to "IS" then
                in parser.error join "expected IS after " c.Tokens:parser.prev ", got " parser.token
                call parser.error
            end if
            call parser.advance
            store parser.token in parser.t
            add parser.run.c and 1 in parser.next
            if c.Tokens:parser.next is equal to "VECTOR" then
                if parser.t is equal to "NUMBER" then
                    store 3 in c.Vars:parser.var
                else if parser.t is equal to "TEXT" then
                    store 4 in c.Vars:parser.var
                else
                    in parser.error join "bad token: " parser.token
                    call parser.error
                end if
                incr parser.run.c
            else
                if parser.t is equal to "NUMBER" then
                    store 1 in c.Vars:parser.var
                else if parser.t is equal to "TEXT" then
                    store 2 in c.Vars:parser.var
                else
                    in parser.error join "bad token: " parser.token
                    call parser.error
                end if
            end if
            incr c.Vars*
        else if parser.mode is equal to 2 then # PROC: section
            call parser.node.create
        else if parser.token is equal to tokens.NEWLINE then
            # ignore rogue newlines
        else
            in parser.error join "unknown parser.mode: " parser.mode
            in parser.error join parser.error " token: " parser.token
            call parser.error
        end if

        incr parser.run.c
    repeat
end sub-procedure
