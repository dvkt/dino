# === PARSER =========================================================
# The parser validates syntax and turns a text vector of tokens into
# DATA and CODE nodes. CODE nodes all live in the c.Nodes vector and
# fake a tree using these vector subindexes:
#
#   * $id            # node type (see nodes.* in compiler.ldpl)
#   * $id:v          # node value
#   * $id:0          # child node type
#   * $id:0:v        # child node value
#   * $id:1
#   * $id:1:v...
#   * $id:1:0        # 1st child of 2nd child...

DATA:
# USES:
# c.Tokens       is text vector
# c.Nodes        is text vector
# c.Nodes*       is number
# c.Vars         is text vector    # num index=names, txt index=type: 1=n,2=t,3=nv,4=tv
# c.Vars*        is number

# OUT:
parser.mode      is number        # 1=data, 2=code
parser.node      is number

parser.run.c     is number        # main iterator
parser.n         is number
parser.i         is number
parser.t         is text
parser.token     is text
parser.error     is text
parser.char      is text
parser.prev      is number
parser.next      is number
parser.var       is text
parser.key       is text
parser.expect    is text

parser.type      is number
parser.child     is number

parser.peek      is text
parser.peek.n    is number

PROCEDURE:
# IN: parser.error
sub-procedure parser.error
    display "parser.error: " parser.error crlf
    display "token " parser.i " of " c.Tokens* crlf
    # exit
end sub-procedure

# Stores next token in `parser.peek`
#  IN: parser.run.c
# OUT: parser.peek
sub-procedure parser.peek
    add 1 and parser.run.c in parser.peek.n
    store c.Tokens:parser.peek.n in parser.peek
end sub-procedure

# Moves the parser forward by one token, setting parser.token.
#  IN: parser.run.c
# OUT: parser.token
#      parser.prev
sub-procedure parser.advance
    store parser.run.c in parser.prev
    incr parser.run.c
    store c.Tokens:parser.run.c in parser.token
end sub-procedure

# Check if the current token is what we want. Errors if not.
#  IN: parser.expect
#      parser.token
sub-procedure parser.expect
    call parser.advance
    if parser.token is not equal to parser.expect then
        in parser.error join "expected " parser.expect ", got " parser.token crlf
        call parser.error
    end if
end sub-procedure

# Identify the type of `parser.token`
#  IN: parser.token
# OUT: parser.type
sub-procedure parser.type.identify
    get character at 0 from parser.token in parser.char

    # number
    store parser.char in digit?.in
    if parser.char is equal to "-" then
        get character at 1 from parser.token in digit?.in
    end if
    call digit?
    if digit? is equal to 1 then
        store $TYPES:"NUM" in parser.type
        return
    end if

    # text
    if parser.char is equal to "\"" then
        store $TYPES:"TXT" in parser.type
        return
    end if

    # variable
    store c.Vars:parser.token in parser.n
    if parser.n is not equal to 0 then
        store parser.n in parser.type
        return
    end if

    in parser.error join "can't identify " parser.token
    call parser.error
end sub-procedure

# Uses the value of `parser.child` to set c.Nodes:$id:$child
sub-procedure parser.node.push-child
    in parser.key join c.Nodes* ":" parser.child
    store parser.token in c.Nodes:parser.key
    join parser.key and ":type" in parser.key
    call parser.type.identify
    store parser.type in c.Nodes:parser.key
end sub-procedure

# sets the value of `parser.token` to c.Nodes:$id:0
sub-procedure parser.node.push-child0
    store 0 in parser.child
    call parser.node.push-child
end sub-procedure
sub-procedure parser.node.push-child1
    store 1 in parser.child
    call parser.node.push-child
end sub-procedure
sub-procedure parser.node.push-child2
    store 2 in parser.child
    call parser.node.push-child
end sub-procedure
sub-procedure parser.node.push-child3
    store 3 in parser.child
    call parser.node.push-child
end sub-procedure

# Parse procedure statement and create a node.
#   IN: c.Nodes
#       parser.token
# NODE:
#   * $id       # node type
#   * $id:0
#   * $id:1
#   * $id:2...
sub-procedure parser.node.create
    if parser.token is equal to tokens.NEWLINE then
        return
    end if

    store parser.token in c.Nodes:c.Nodes*

    if "STORE" is equal to parser.token then
        call parser.advance
        call parser.node.push-child0
        store tokens.IN in parser.expect
        call parser.expect
        call parser.advance
        call parser.node.push-child1
    else if "DISPLAY" is equal to parser.token then
        call parser.advance
        call parser.node.push-child0
        # vargs...
        store 1 in parser.child
        while parser.child is less than 8 do
            call parser.peek
            if parser.peek is equal to tokens.NEWLINE then
                break
            else if parser.peek is equal to "" then
                break
            else
                call parser.advance
                call parser.node.push-child
            end if
            incr parser.child
        repeat
    else if "ACCEPT" is equal to parser.token then
        call parser.advance
        call parser.node.push-child
    else if "TEMPLATE" is equal to parser.token then
        call parser.advance
    else
        # display "IGNORING: " parser.token crlf
    end if

    incr c.Nodes*
end sub-procedure

#  IN: c.Tokens
# OUT: c.Nodes
#      c.Vars
sub-procedure parser.Run
    store 0 in parser.run.c
    store 0 in parser.mode
    store 0 in c.Nodes*
    while parser.run.c is less than c.Tokens* do
        subtract 1 from parser.run.c in parser.prev
        store c.Tokens:parser.run.c in parser.token
        get character at 0 from parser.token in parser.char

        if parser.token is equal to "DATA:" then
            store 1 in parser.mode
        else if parser.token is equal to "PROCEDURE:" then
            store 2 in parser.mode
        else if parser.mode is equal to 1 then # DATA: section
            if parser.token is equal to tokens.newline then
                incr parser.run.c
                continue
            end if
            store parser.token in c.Vars:c.Vars*
            store parser.token in parser.var
            call parser.advance
            if parser.token is not equal to tokens.is then
                in parser.error join "expected IS after " c.Tokens:parser.prev ", got " parser.token
                call parser.error
            end if
            call parser.advance
            store parser.token in parser.t
            add parser.run.c and 1 in parser.next
            if c.Tokens:parser.next is equal to tokens.vector then
                if parser.t is equal to tokens.number then
                    store 3 in c.Vars:parser.var
                else if parser.t is equal to tokens.text then
                    store 4 in c.Vars:parser.var
                else
                    in parser.error join "bad token: " parser.token
                    call parser.error
                end if
                incr parser.run.c
            else
                if parser.t is equal to tokens.number then
                    store 1 in c.Vars:parser.var
                else if parser.t is equal to tokens.text then
                    store 2 in c.Vars:parser.var
                else
                    in parser.error join "bad token: " parser.token
                    call parser.error
                end if
            end if
            incr c.Vars*
        else if parser.mode is equal to 2 then # PROC: section
            call parser.node.create
        else if parser.token is equal to tokens.newline then
            display "IGNNORING: " parser.token crlf
            # ignore rogue newlines
        else
            in parser.error join "unknown parser.mode: " parser.mode
            in parser.error join parser.error " token: " parser.token
            call parser.error
        end if

        incr parser.run.c
    repeat
end sub-procedure
