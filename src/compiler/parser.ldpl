# === PARSER =========================================================
# The parser validates syntax and turns a text vector of tokens into
# DATA and CODE nodes.
# CODE nodes all live in the c.Nodes vector and fake a struct
# using these keys:
#   * $id:type
#   * $id:x
#   * $id:y
#   * $id:z
#   * $id:arg1...
#   * $id:arg0
#   * $id:argc
# Most nodes follow this format. Others may have other fields with
# information unique to that node. See nodes.ldpl

DATA:
# USES:
# c.Tokens       is text vector
# c.Nodes        is text vector

# OUT:                            # 1=num,2=text,3=nv,4=tv
parser.tnames    is text vector   # human names of types
parser.types     is number vector # type of each variable
parser.names     is text vector   # human names of variables
parser.names*    is number
parser.mode      is number        # 1=data, 2=code
parser.node      is number

parser.i         is number
parser.n         is number
parser.t         is text
parser.token     is text
parser.error     is text
parser.char      is text
parser.prev      is number
parser.next      is number
parser.var       is text
parser.type      is text

parser.x         is text
parser.y         is text
parser.z         is text
parser.expect    is text
parser.key.x     is text
parser.key.y     is text
parser.key.z     is text
parser.key.type  is text

PROCEDURE:
store "NUM" in parser.tnames:1
store "TXT" in parser.tnames:2
store "NMV" in parser.tnames:3
store "TXV" in parser.tnames:4

# IN: parser.error
sub-procedure parser.error
    display "parser.error: " parser.error crlf
    display "token " parser.i " of " c.Tokens* crlf
    exit
end sub-procedure

#  IN: parser.i
# OUT: parser.token
#      parser.prev
sub-procedure parser.advance
    store parser.i in parser.prev
    incr parser.i
    store c.Tokens:parser.i in parser.token
end sub-procedure

sub-procedure parser.expect
    call parser.advance
    if parser.token is not equal to parser.expect then
        in parser.error join "expected " parser.expect ", got " parser.token crlf
        call parser.error
    end if
end sub-procedure

# Parse procedure statement
#   IN: parser.token
# NODE:
#   * $id       # node type
#   * $id:x
#   * $id:y
#   * $id:z
#   * $id:arg1...
#   * $id:arg0
#   * $id:argc
sub-procedure parser.proc.parse
    if "STORE" is equal to parser.token then
        join c.Nodes* and ":x" in parser.key.x
        join c.Nodes* and ":y" in parser.key.y

        call parser.advance
        store parser.token in parser.x
        store tokens.IN in parser.expect
        call parser.expect
        call parser.advance
        store parser.token in parser.y

        store "STORE" in c.Nodes:c.Nodes*
        store parser.x in c.Nodes:parser.key.x
        store parser.y in c.Nodes:parser.key.y
        incr c.Nodes*
    else if "DISPLAY" is equal to parser.token then
        display "herp" crlf
    end if
end sub-procedure

#  IN: c.Tokens
# OUT: c.Nodes
#      parser.types
#      parser.names
sub-procedure parser.run
    store 0 in parser.i
    store 0 in parser.mode
    store 0 in c.Nodes*
    while parser.i is less than c.Tokens* do
        subtract 1 from parser.i in parser.prev
        store c.Tokens:parser.i in parser.token
        get character at 0 from parser.token in parser.char

        if parser.token is equal to "DATA:" then
            store 1 in parser.mode
        else if parser.token is equal to "PROCEDURE:" then
            store 2 in parser.mode
        else if parser.mode is equal to 1 then # DATA: section
            if parser.token is equal to tokens.newline then
                incr parser.i
                continue
            end if

            store parser.token in parser.var
            call parser.advance
            if parser.token is not equal to tokens.is then
                in parser.error join "expected IS after " c.Tokens:parser.prev ", got " parser.token
                call parser.error
            end if
            call parser.advance
            store parser.token in parser.type
            add parser.i and 1 in parser.next
            if c.Tokens:parser.next is equal to tokens.vector then
                if parser.type is equal to tokens.number then
                    store 3 in parser.types:parser.names*
                else if parser.type is equal to tokens.text then
                    store 4 in parser.types:parser.names*
                end if
                incr parser.i
            else
                if parser.type is equal to tokens.number then
                    store 1 in parser.types:parser.names*
                else if parser.type is equal to tokens.text then
                    store 2 in parser.types:parser.names*
                end if
            end if
            store parser.var in parser.names:parser.names*
            incr parser.names*
        else if parser.mode is equal to 2 then # PROC: section
            call parser.proc.parse
        else if parser.token is equal to tokens.newline then
            # ignore rogue newlines
        else
            in parser.error join "unknown parser.mode: " parser.mode
            in parser.error join parser.error " token: " parser.token
            call parser.error
        end if

        incr parser.i
    repeat
end sub-procedure
