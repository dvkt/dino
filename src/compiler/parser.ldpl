# === PARSER =========================================================
# The parser validates syntax (kinda) and turns a text vector of
# tokens into two vectors: code nodes and variables.
#
# The variables vector, c.Vars, is actually two vectors in one:
#   - Number subindexes give you the name of a variable.
#   - Text subindexes give the variable's $type.
#
# The code vector, cNodes, fakes a struct with the following key
# structure:
#   - $id         # node name
#   - $id:0       # 1st argument
#   - $id:0:type  # 1st argument's $type
#   - $id:1       # 2nd argument...
#   - $id:1:type
# And so on.

DATA:
# OUT:
parser.mode      is number        # 1=data, 2=code
parser.node      is number

parser.run.c     is number        # main iterator
parser.n         is number
parser.i         is number
parser.t         is text
parser.token     is text
parser.char      is text
parser.prev      is number
parser.next      is number
parser.var       is text
parser.key       is text
parser.expect    is text

parser.type      is number
parser.arg       is number

parser.peek      is text
parser.peek.n    is number

parser.error     is text
parser.error.i   is number

PROCEDURE:
# IN: parser.error
sub-procedure parser.error
    display "parser.error: " parser.error crlf
    display "token " parser.run.c " of " c.Tokens* crlf
    while parser.error.i is less than c.Tokens* do
        if parser.error.i is equal to parser.run.c then
            display "\e[33;1m" c.Tokens:parser.error.i "\e[0m "
        else
            display c.Tokens:parser.error.i " "
        end if
        incr parser.error.i
    repeat
    exit
end sub-procedure

# Stores next token in `parser.peek`
#  IN: parser.run.c
# OUT: parser.peek
sub-procedure parser.peek
    add 1 and parser.run.c in parser.peek.n
    store c.Tokens:parser.peek.n in parser.peek
end sub-procedure

# Moves the parser forward by one token, setting parser.token.
#  IN: parser.run.c
# OUT: parser.token
#      parser.prev
sub-procedure parser.advance
    store parser.run.c in parser.prev
    incr parser.run.c
    store c.Tokens:parser.run.c in parser.token
end sub-procedure

# Check if the current token is what we want. Errors if not.
#  IN: parser.expect
#      parser.token
sub-procedure parser.expect
    call parser.advance
    if parser.token is not equal to parser.expect then
        in parser.error join "expected " parser.expect ", got " parser.token crlf
        call parser.error
    end if
end sub-procedure

# Identify the type of `parser.token`
#  IN: parser.token
# OUT: parser.type
sub-procedure parser.type.identify
    get character at 0 from parser.token in parser.char

    # number
    store parser.char in digit?.in
    if parser.char is equal to "-" then
        get character at 1 from parser.token in digit?.in
    end if
    call digit?
    if digit? is equal to 1 then
        store $TYPES:"NML" in parser.type
        return
    end if

    # text
    if parser.char is equal to "\"" then
        store $TYPES:"TXL" in parser.type
        return
    end if

    # variable
    store c.Vars:parser.token in parser.n
    if parser.n is not equal to 0 then
        store parser.n in parser.type
        return
    end if

    in parser.error join "can't identify " parser.token
    call parser.error
end sub-procedure

# Uses the value of `parser.arg` to set c.Nodes:$id:$arg
sub-procedure parser.node.set
    in parser.key join c.Nodes* ":" parser.arg
    store parser.token in c.Nodes:parser.key
    join parser.key and ":type" in parser.key
    call parser.type.identify
    store parser.type in c.Nodes:parser.key
end sub-procedure

# sets the value of `parser.token` to c.Nodes:$id:0
sub-procedure parser.node.set0
    store 0 in parser.arg
    call parser.node.set
end sub-procedure
sub-procedure parser.node.set1
    store 1 in parser.arg
    call parser.node.set
end sub-procedure
sub-procedure parser.node.set2
    store 2 in parser.arg
    call parser.node.set
end sub-procedure
sub-procedure parser.node.set3
    store 3 in parser.arg
    call parser.node.set
end sub-procedure

# Parse procedure statement and create a node.
#   IN: c.Nodes
#       parser.token
# NODE:
#   * $id       # node type
#   * $id:0
#   * $id:1
#   * $id:2...
sub-procedure parser.node.create
    if parser.token is equal to tokens.NEWLINE then
        return
    end if

    store parser.token in c.Nodes:c.Nodes*
    store 0 in parser.arg

    if "STORE" is equal to parser.token then
        call parser.advance
        call parser.node.set0
        store "IN" in parser.expect
        call parser.expect
        call parser.advance
        call parser.node.set1
    else if "DISPLAY" is equal to parser.token then
        call parser.advance
        call parser.node.set0
        # vargs...
        store 1 in parser.arg
        while parser.arg is less than 8 do
            call parser.peek
            if parser.peek is equal to tokens.NEWLINE then
                break
            else if parser.peek is equal to "" then
                break
            else
                call parser.advance
                call parser.node.set
            end if
            incr parser.arg
        repeat
    else if "ADD" is equal to parser.token then
        call parser.advance
        call parser.node.set0
        store "AND" in parser.expect
        call parser.expect
        call parser.advance
        call parser.node.set1
        store "IN" in parser.expect
        call parser.expect
        call parser.advance
        call parser.node.set2
    else if "SUBTRACT" is equal to parser.token then
        call parser.advance
        call parser.node.set0
        store "FROM" in parser.expect
        call parser.expect
        call parser.advance
        call parser.node.set1
        store "IN" in parser.expect
        call parser.expect
        call parser.advance
        call parser.node.set2
    else if "ACCEPT" is equal to parser.token then
        call parser.advance
        call parser.node.set0
    else if "TEMPLATE" is equal to parser.token then
        call parser.advance
    else
        # display "IGNORING: " parser.token crlf
    end if

    incr c.Nodes*
end sub-procedure

#  IN: c.Tokens
# OUT: c.Nodes
#      c.Vars
sub-procedure parser.Run
    store 0 in parser.run.c
    store 0 in parser.mode
    store 0 in c.Nodes*
    while parser.run.c is less than c.Tokens* do
        subtract 1 from parser.run.c in parser.prev
        store c.Tokens:parser.run.c in parser.token
        get character at 0 from parser.token in parser.char

        if parser.token is equal to "DATA:" then
            store 1 in parser.mode
        else if parser.token is equal to "PROCEDURE:" then
            store 2 in parser.mode
        else if parser.mode is equal to 1 then # DATA: section
            if parser.token is equal to tokens.NEWLINE then
                incr parser.run.c
                continue
            end if
            store parser.token in c.Vars:c.Vars*
            store parser.token in parser.var
            call parser.advance
            if parser.token is not equal to "IS" then
                in parser.error join "expected IS after " c.Tokens:parser.prev ", got " parser.token
                call parser.error
            end if
            call parser.advance
            store parser.token in parser.t
            add parser.run.c and 1 in parser.next
            if c.Tokens:parser.next is equal to "VECTOR" then
                if parser.t is equal to "NUMBER" then
                    store 3 in c.Vars:parser.var
                else if parser.t is equal to "TEXT" then
                    store 4 in c.Vars:parser.var
                else
                    in parser.error join "bad token: " parser.token
                    call parser.error
                end if
                incr parser.run.c
            else
                if parser.t is equal to "NUMBER" then
                    store 1 in c.Vars:parser.var
                else if parser.t is equal to "TEXT" then
                    store 2 in c.Vars:parser.var
                else
                    in parser.error join "bad token: " parser.token
                    call parser.error
                end if
            end if
            incr c.Vars*
        else if parser.mode is equal to 2 then # PROC: section
            call parser.node.create
        else if parser.token is equal to tokens.NEWLINE then
            # ignore rogue newlines
        else
            in parser.error join "unknown parser.mode: " parser.mode
            in parser.error join parser.error " token: " parser.token
            call parser.error
        end if

        incr parser.run.c
    repeat
end sub-procedure
