# === PARSER =========================================================
# The parser validates syntax and turns a text vector of tokens into
# DATA and CODE nodes. CODE nodes all live in the c.Nodes vector and
# fake a struct using these vector subindexes:
#
#   * $id              # node type  1=n,2=t,3=nv,4=tv
#   * $id:arg0         # 1st arg
#   * $id:arg1
#   * $id:arg2...
#   * $id:arg7
#   * $id:arg0:type    # type of 1st arg
#
# Most nodes follow this format. Others may have other fields with
# information unique to that node, such as IF.

DATA:
# USES:
# c.Tokens       is text vector
# c.Nodes        is text vector
# c.Nodes*       is number
# c.Types        is number vector  # variable types. 1=n,2=t,3=nv,4=tv
# c.Vars         is text vector    # variable names
# c.Vars*        is number

# OUT:                            # 1=num,2=text,3=nv,4=tv
parser.mode      is number        # 1=data, 2=code
parser.node      is number

parser.run.c     is number        # main iterator
parser.n         is number
parser.i         is number
parser.t         is text
parser.token     is text
parser.error     is text
parser.char      is text
parser.prev      is number
parser.next      is number
parser.var       is text
parser.type      is text
parser.key       is text
parser.expect    is text

parser.arg       is number

parser.peek      is text
parser.peek.n    is number

PROCEDURE:
# IN: parser.error
sub-procedure parser.error
    display "parser.error: " parser.error crlf
    display "token " parser.i " of " c.Tokens* crlf
    exit
end sub-procedure

# Stores next token in `parser.peek`
#  IN: parser.run.c
# OUT: parser.peek
sub-procedure parser.peek
    add 1 and parser.run.c in parser.peek.n
    store c.Tokens:parser.peek.n in parser.peek
end sub-procedure

# Moves the parser forward by one token, setting parser.token.
#  IN: parser.run.c
# OUT: parser.token
#      parser.prev
sub-procedure parser.advance
    store parser.run.c in parser.prev
    incr parser.run.c
    store c.Tokens:parser.run.c in parser.token
end sub-procedure

# Check if the current token is what we want. Errors if not.
#  IN: parser.expect
#      parser.token
sub-procedure parser.expect
    call parser.advance
    if parser.token is not equal to parser.expect then
        in parser.error join "expected " parser.expect ", got " parser.token crlf
        call parser.error
    end if
end sub-procedure

# Uses the value of `parser.arg` to set c.Nodes:$id:arg
sub-procedure parser.node.set-arg
    in parser.key join c.Nodes* ":arg" parser.arg
    store parser.token in c.Nodes:parser.key
end sub-procedure
# sets the value of `parser.token` to c.Nodes:$id:arg0
sub-procedure parser.node.set-arg0
    join c.Nodes* and ":arg0" in parser.key
    store parser.token in c.Nodes:parser.key
end sub-procedure
sub-procedure parser.node.set-arg1
    join c.Nodes* and ":arg1" in parser.key
    store parser.token in c.Nodes:parser.key
end sub-procedure
sub-procedure parser.node.set-arg2
    join c.Nodes* and ":arg2" in parser.key
    store parser.token in c.Nodes:parser.key
end sub-procedure
sub-procedure parser.node.set-arg3
    join c.Nodes* and ":arg3" in parser.key
    store parser.token in c.Nodes:parser.key
end sub-procedure
sub-procedure parser.node.set-arg4
    join c.Nodes* and ":arg4" in parser.key
    store parser.token in c.Nodes:parser.key
end sub-procedure

# Parse procedure statement and create a node.
#   IN: c.Nodes
#       parser.token
# NODE:
#   * $id       # node type
#   * $id:x
#   * $id:y
#   * $id:z
#   * $id:arg1...
#   * $id:arg0
#   * $id:argc
sub-procedure parser.node.create
    if parser.token is equal to tokens.NEWLINE then
        return
    end if

    store parser.token in c.Nodes:c.Nodes*

    if "STORE" is equal to parser.token then
        call parser.advance
        call parser.node.set-arg0
        store tokens.IN in parser.expect
        call parser.expect
        call parser.advance
        call parser.node.set-arg1
    else if "DISPLAY" is equal to parser.token then
        call parser.advance
        call parser.node.set-arg0
        # vargs...
        store 1 in parser.arg
        while parser.arg is less than 8 do
            call parser.peek
            if parser.peek is equal to tokens.NEWLINE then
                break
            else
                call parser.advance
                call parser.node.set-arg
            end if
            incr parser.arg
        repeat
    else if "ACCEPT" is equal to parser.token then
        call parser.advance
        call parser.node.set-arg0
    else if "TEMPLATE" is equal to parser.token then
        call parser.advance
    else
        # display "IGNORING: " parser.token crlf
    end if

    incr c.Nodes*
end sub-procedure

#  IN: c.Tokens
# OUT: c.Nodes
#      c.Types
#      c.Vars
sub-procedure parser.Run
    store 0 in parser.run.c
    store 0 in parser.mode
    store 0 in c.Nodes*
    while parser.run.c is less than c.Tokens* do
        subtract 1 from parser.run.c in parser.prev
        store c.Tokens:parser.run.c in parser.token
        get character at 0 from parser.token in parser.char

        if parser.token is equal to "DATA:" then
            store 1 in parser.mode
        else if parser.token is equal to "PROCEDURE:" then
            store 2 in parser.mode
        else if parser.mode is equal to 1 then # DATA: section
            if parser.token is equal to tokens.newline then
                incr parser.run.c
                continue
            end if
            store parser.token in parser.var
            call parser.advance
            if parser.token is not equal to tokens.is then
                in parser.error join "expected IS after " c.Tokens:parser.prev ", got " parser.token
                call parser.error
            end if
            call parser.advance
            store parser.token in parser.type
            add parser.run.c and 1 in parser.next
            if c.Tokens:parser.next is equal to tokens.vector then
                if parser.type is equal to tokens.number then
                    store 3 in c.Types:c.Vars*
                else if parser.type is equal to tokens.text then
                    store 4 in c.Types:c.Vars*
                end if
                incr parser.run.c
            else
                if parser.type is equal to tokens.number then
                    store 1 in c.Types:c.Vars*
                else if parser.type is equal to tokens.text then
                    store 2 in c.Types:c.Vars*
                end if
            end if
            store parser.var in c.Vars:c.Vars*
            incr c.Vars*
        else if parser.mode is equal to 2 then # PROC: section
            call parser.node.create
        else if parser.token is equal to tokens.newline then
            display "IGNNORING: " parser.token crlf
            # ignore rogue newlines
        else
            in parser.error join "unknown parser.mode: " parser.mode
            in parser.error join parser.error " token: " parser.token
            call parser.error
        end if

        incr parser.run.c
    repeat
end sub-procedure
