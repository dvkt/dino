# === LEXER ==========================================================
# The lexer turns source code into a text vector of tokens.
DATA:
# USES:
# c.Input

# IN:

# OUT:
lexer.chars          is text vector  # every letter

# LOCAL:
lexer.ci             is number       # current character index
lexer.char           is text         # current character
lexer.next           is number       # idx of next character
lexer.prev           is number       # idx of previous character
lexer.token          is text         # current token
lexer.text?          is number       # are we lexing a string?
lexer.comment?       is number       # are we lexing a comment?
c.Tokens.i           is number       # for clearing the list
c.Input*             is number       # input length

lexer.error          is text
lexer.error.i        is number

PROCEDURE:
# IN: lexer.error
# IN: lexer.ci
sub-procedure lexer.error
    display "lexer.error: " lexer.error crlf
    display "character " lexer.ci " of " c.Input* crlf
    store 0 in lexer.error.i
    while lexer.error.i is less than c.Tokens* do
        if lexer.error.i is equal to lexer.ci then
            display "\e[33;1m" c.Tokens:lexer.error.i "\e[0m "
        else
            display c.Tokens:lexer.error.i " "
        end if
        incr lexer.error.i
    repeat
    exit
end sub-procedure

# Adds `token.push` to c.Tokens and clears `lexer.token`
#  IN: lexer.token
# OUT: c.Tokens
sub-procedure lexer.token.push
    # TODO big ol' CRLF hack
    if lexer.token is equal to tokens.CRLF then
        store "\"\\r\\n\"" in lexer.token
    end if

    store lexer.token in c.Tokens:c.Tokens*
    incr c.Tokens*
    store "" in lexer.token
end sub-procedure

#  IN: c.Input
# OUT: c.Tokens(*)
sub-procedure lexer.Run
    store length of c.Input in c.Input*
    split c.Input by "" in lexer.chars
    store 0 in lexer.comment?
    store 0 in lexer.text?
    store 0 in lexer.ci
    store 0 in c.Tokens*
    store "" in lexer.char
    store "" in lexer.token
    while lexer.ci is less than c.Input* do
        subtract 1 from lexer.ci in lexer.prev
        store lexer.chars:lexer.ci in lexer.char

        if lexer.comment? is equal to 1 then
            if lexer.char is equal to "\n" then
                store 0 in lexer.comment?
                store tokens.NEWLINE in lexer.token
                call lexer.token.push
            end if
            incr lexer.ci
            continue
        else if lexer.text? is equal to 1 then
            if lexer.char is equal to "\\" then
                add lexer.ci and 1 in lexer.next
                if lexer.chars:lexer.next is equal to "\\" then
                    incr lexer.ci
                    store "\\\\" in lexer.char
                else if lexer.chars:lexer.next is equal to "\"" then
                    incr lexer.ci
                    store "\\\"" in lexer.char
                end if
            else if lexer.char is equal to "\"" then
                store 0 in lexer.text?
            end if

            incr lexer.ci
            join lexer.token and lexer.char in lexer.token
            continue
        end if

        if lexer.char is equal to "\n" then
            # store current token in tokens vector
            if lexer.token is not equal to "" then
                call lexer.token.push
            end if

            # add newline token
            store tokens.NEWLINE in lexer.token
            call lexer.token.push
        else if lexer.char is equal to " " then
            # store current token in tokens vector
            if lexer.token is not equal to "" then
                call lexer.token.push
            end if
        else if lexer.char is equal to "#" then
            if lexer.token is not equal to "" then
                call lexer.token.push
            end if
            store 1 in lexer.comment?
        else if lexer.char is equal to "\"" then
            # open string
            store 1 in lexer.text?
            join lexer.token and lexer.char in lexer.token
        else if lexer.char is equal to "\r" then
            # ignore
        else
            # upcase letter
            store lexer.char in upcase.letter
            call upcase-letter
            store upcase.letter in lexer.char

            # store char in current token
            join lexer.token and lexer.char in lexer.token
        end if

        # increment reader counter
        add 1 and lexer.ci in lexer.ci
    repeat
end sub-procedure
