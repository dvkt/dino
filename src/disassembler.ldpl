# === DISASSEMBLER ===================================================
# The disassembler converts dino bytecode into text assembly code.
DATA:
# PUBLIC:
dis.text is text

# CONFIG:
dis.color.opcode  is text
dis.color.opname  is text
dis.color.operand is text

# LOCALS:
dis.opcode        is number
dis.i             is number

PROCEDURE:
store "\e[36m" in dis.color.opcode  # cyan
store "\e[33m" in dis.color.opname  # gold
store "\e[35m" in dis.color.operand # pink

# Decompiles bytecode to text representation. Not faithful to the
# original ASM.
#  IN: $bytecode
#      $bytecode.len
# OUT: dis.text
# CFG: dis.color.opcode
#      dis.color.opname
#      dis.color.operand
sub-procedure dis.decompile
    store 5 in dis.i
    store "" in dis.text
    while dis.i is less than $bytecode.len do
        store $bytecode:dis.i in dis.opcode

        join dis.text and dis.color.opcode in dis.text
        if dis.opcode is less than 10 then
            join dis.text and 0 in dis.text
        end if
        in dis.text join dis.opcode dis.color.opname opnames:dis.opcode "  "
        if opsizes:dis.opcode is greater than 0 then
            store opsizes:dis.opcode in dis.x
            store 0 in dis.j
            while dis.j is less than dis.x do
                add 1 and dis.i in dis.i
                join dis.text and dis.color.operand in dis.text
                store $bytecode:dis.i in dis.opcode
                if dis.opcode is greater than or equal to $text-offset then
                    subtract $text-offset from dis.opcode in dis.opcode
                    join dis.text and $constants:dis.opcode in dis.text
                else
                    join dis.text and dis.opcode in dis.text
                end if
                add 1 and dis.j in dis.j
                if dis.j is less than dis.x then
                    join dis.text and "\e[0m, " in dis.text
                end if
            repeat
        end if
        join dis.text and crlf in dis.text
        add 1 and dis.i in dis.i
    repeat
end sub-procedure