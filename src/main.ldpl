#                                  .
#                               &*****
#     dino:                   (********@
#      ~ an ~                 ***/
#       ~ LDPL ~             @***
#        ~ interpreter ~     &@
#         ~ in ~            %**%%
#          ~ LDPL ~         &**((
#                        %%******
#                (( ((&**********
#          (@********************
#         /**********************
#        ***********************,.&
#       ***********************######
#     (*** ****/**************@#%####,
#   @**&   **** ****.****.****#######(

# === DINO ===========================================================
# The `dino` command line program.

DATA:
main.i       is number
main.x       is number
main.l       is number
main.char    is text
main.ext     is text
main.key     is text

PROCEDURE:
# --- DISPLAY VERSION ------------------------------------------------
# $ dino version
sub-procedure main.version
    display "\e[0mðŸ¦– dino " $DINO.VERSION " (" $DINO.BUILT ") ðŸ¦–\e[0m" crlf
end sub-procedure

# --- DISPLAY HELP ---------------------------------------------------
# $ dino help
sub-procedure main.help
    display "Usage: $ dino [command] [options...]" crlf
    display crlf
    display "Commands:" crlf
    display "\t" "run  " "\t" "execute .ldpl, .dino, or .dinocode file" crlf
    display "\t" "asm  " "\t" "compile .ldpl file to .dino assembly" crlf
    display "\t" "bytes" "\t" "compile .ldpl or .dino file to .dinocode bytecode" crlf
    display "\t" "dis  " "\t" "disassemble .dinocode file to .dino assembly" crlf
    display "\t" "lex  " "\t" "lex .ldpl file and print tokens" crlf
    display "\t" "parse" "\t" "parse .ldpl file and print nodes" crlf
    display "\t" "help " "\t" "print help screen" crlf
end sub-procedure

# Strip dino related command line arguments from argv and update argc.
#    argv: "run" "file.dino" "123" "456"
# -> argv: "123" "456"
sub-procedure main.strip-args
    store 2 in main.i
    store 0 in main.x
    while main.i is less than argc do
        store argv:main.i in argv:main.x
        incr main.i
        incr main.x
    repeat
    subtract 2 from argc in argc
end sub-procedure

# --- READ-EVAL-PRINT-LOOP -------------------------------------------
# $ dino run file.ldpl
# The REPL reads, evaluates, and prints LDPL source code in a loop.
sub-procedure main.repl
end sub-procedure

# --- LEX FILE -------------------------------------------------------
# $ dino lex file.ldpl
sub-procedure main.lex
    load file argv:1 in c.Input
    call lexer.Run
    store 0 in main.i
    display "tokens:\n  "
    while main.i is less than c.Tokens* do
        display "\e[36m<\e[33m" c.Tokens:main.i "\e[36m>"
        incr main.i
        if main.i is less than c.Tokens* then
            display "\e[0m, "
        end if
    repeat
    display "\e[0m"
end sub-procedure

# --- PARSE FILE -----------------------------------------------------
# $ dino parse file.ldpl
sub-procedure main.parse
    load file argv:1 in c.Input
    call lexer.Run
    call parser.Run
    store 0 in main.i
    display "nodes (" c.Nodes* "):\n"
    while main.i is less than c.Nodes* do
        display "  " c.Nodes:main.i crlf
        store 0 in main.x
        while main.x is less than 8 do
            in main.key join main.i ":arg" main.x
            if c.Nodes:main.key is not equal to "" then
                display "    - a" main.x ": " c.Nodes:main.key crlf
            end if
            incr main.x
        repeat
        incr main.i
    repeat
    display "vars:\n"
    store 0 in main.i
    while main.i is less than c.Vars* do
        display "  #<" $TYPES:c.Types:main.i ": " c.Vars:main.i ">" crlf
        incr main.i
    repeat
    display "\e[0m"
end sub-procedure

# --- RUN FILE -------------------------------------------------------
# $ dino run file.ldpl
sub-procedure main.run.ldpl
    display "\e[1;31mNOT IMPLEMENTED\e[0m" crlf
    exit
end sub-procedure

# $ dino run file.dino
sub-procedure main.run.dino
    load file argv:1 in c.Asm
    if ERRORCODE is greater than 0 then
        display ERRORTEXT crlf
        exit
    end if
    call asm.Compile
    call asm.To-dinocode
    store asm.Dinocode in loader.input
    call main.strip-args
    call vm.Boot
    call loader.Run
    call cpu.Run
end sub-procedure

# $ dino run file.dinocode
sub-procedure main.run.dinocode
    load file argv:1 in loader.Input
    if ERRORCODE is greater than 0 then
        display errortext crlf
        exit
    end if
    call main.strip-args
    call vm.Boot
    call loader.Run
    call cpu.Run
end sub-procedure

# $ dino run file
sub-procedure main.run
    store 0 in main.i
    store "" in main.ext
    store length of argv:1 in main.l

    while main.i is less than main.l do
        get character at main.i from argv:1 in main.char
        if main.char is equal to "." then
            add 1 and main.i in main.i
            get character at main.i from argv:1 in main.ext
        else if main.ext is not equal to "" then
            join main.ext and main.char in main.ext
        end if
        add 1 and main.i in main.i
    repeat

    store main.ext in upcase.word
    call upcase-word
    store upcase.word in main.ext

    if main.ext is equal to "LDPL" then
        call main.run.ldpl
    else if main.ext is equal to "DINO" then
        call main.run.dino
    else if main.ext is equal to "DINOCODE" then
        call main.run.dinocode
    else
        display "\e[1;31mBad file extension: \e[0m" main.ext crlf
        exit
    end if
end sub-procedure

# --- CONVERT LDPL TO ASSEMBLY ---------------------------------------
# $ dino asm file.ldpl
sub-procedure main.ldpl-to-asm
    load file argv:1 in c.Input
    if ERRORCODE is greater than 0 then
        display ERRORTEXT crlf
        exit
    end if
    call lexer.Run
    call parser.Run
    call generator.Run
    display c.Asm crlf
end sub-procedure

# --- CONVERT LDPL TO BYTECODE ---------------------------------------
# $ dino bytes file.ldpl
sub-procedure main.ldpl-to-bytecode
end sub-procedure

# --- CONVERT ASSEMBLY TO BYTECODE -----------------------------------
# $ dino bytes file.dino
sub-procedure main.asm-to-bytecode
    load file argv:1 in c.Asm
    if ERRORCODE is greater than 0 then
        display ERRORTEXT crlf
        exit
    end if
    call asm.Compile
    call asm.Print
end sub-procedure

# --- CONVERT BYTECODE TO ASSEMBLY -----------------------------------
# $ dino dis file.dinocode
sub-procedure main.bytecode-to-asm
    load file argv:1 in loader.Input
    call loader.Run
    call dis.Print
end sub-procedure

# --- MAIN PROGRAM ROUTINE -------------------------------------------
sub-procedure main
    if argv:0 is equal to "bytes" then
        call main.asm-to-bytecode
    else if argv:0 is equal to "run" then
        call main.run
    else if argv:0 is equal to "asm" then
        call main.ldpl-to-asm
    else if argv:0 is equal to "dis" then
        call main.bytecode-to-asm
    else if argv:0 is equal to "lex" then
        call main.lex
    else if argv:0 is equal to "parse" then
        call main.parse
    else if argv:0 is equal to "-v" then
        call main.version
    else if argv:0 is equal to "version" then
        call main.version
    else
        call main.help
    end if
end sub-procedure

call main

#              boing         boing         boing
#    e-e           . - .         . - .         . - .
#   (\_/)\       '       `.   ,'       `.   ,'       .
#    `-'\ `--.___,         . .           . .          .
#       '\( ,_.-'
#          \\               "             "            a:f
#          ^'
