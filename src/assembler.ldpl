# === ASSEMBLER ======================================================
# The assembler converts text assembly code into dino bytecode.
DATA:
# IN:
asm.input         is text

# OUT:
asm.bytecode      is number vector  # bytecode
asm.bytecode.len  is number
asm.constants     is text vector    # text constants
asm.constants.len is number
asm.textcode      is text           # text (file) version of bytecod

# CONSTANTS:
asm.text-offset   is number

# INTERNALS:
asm.labels        is number vector
asm.variables     is number vector
asm.variables.len is number
asm.lines         is text vector
asm.lines.len     is number
asm.tokens        is text vector
asm.tokens.len    is number
asm.token         is text
asm.token.label?  is number
asm.label         is text
asm.address       is number
asm.pc            is number  # program counter

# LOCALS:
asm.line          is text
asm.len           is number
asm.i             is number
asm.x             is number
asm.t             is text
asm.size          is number
asm.char          is text
asm.prev          is text
asm.comment?      is number
asm.string?       is number

PROCEDURE:
store 12288 in asm.text-offset # 0x3000

#  IN: asm.token
# OUT: asm.token.label?
sub-procedure asm.token.label?
    store length of asm.token in asm.x
    subtract 1 from asm.x in asm.x
    get character at asm.x from asm.token in asm.char
    store 0 in asm.token.label?
    if asm.char is equal to ":" then
        store 1 in asm.token.label?
    end if
end sub-procedure

#  IN: asm.token
# OUT: asm.token
sub-procedure asm.token.strip-trailing-colon
    store length of asm.token in asm.len
    subtract 1 from asm.len in asm.len
    store 0 in asm.x
    store "" in asm.t
    while asm.x is less than asm.len do
        get character at asm.x from asm.token in asm.char
        join asm.t and asm.char in asm.t
        add 1 and asm.x in asm.x
    repeat
    store asm.t in asm.token
end sub-procedure

# Convert tokens of ASM source code to memory address.
#  IN: asm.token
# OUT: asm.address
sub-procedure asm.token.to-address
    get character at 0 from asm.token in asm.char
    if asm.char is equal to "\"" then
        add asm.text-offset and asm.constants.len in asm.address
        store asm.token in asm.constants:asm.constants.len
        add 1 and asm.constants.len in asm.constants.len
    else if asm.char is equal to "$" then
        store REGISTERS:asm.token in asm.address
    else if asm.char is equal to "%" then
        # variables
        if asm.variables:asm.token is equal to 0 then
            add 1 and asm.variables.len in asm.variables.len
            store asm.variables.len in asm.variables:asm.token
        end if
        store asm.variables:asm.token in asm.address
    else
        get character at 0 from asm.token in digit?.in
        call digit?
        if digit? is equal to 1 then
            store asm.token in asm.address
        else
            store asm.labels:asm.token in asm.address
        end if
    end if
end sub-procedure

#  IN: asm.tokens
#      asm.tokens.len
# OUT: asm.labels
sub-procedure asm.tokens.find-labels
    store 0 in asm.pc
    while asm.pc is less than asm.tokens.len do
        store asm.tokens:asm.pc in asm.token
        call asm.token.label?
        if asm.token.label? is equal to 1 then
            call asm.token.strip-trailing-colon
            store asm.pc in asm.labels:asm.token
        end if
        add 1 and asm.pc in asm.pc
    repeat
end sub-procedure

# Converts text tokens to bytecode and text constants.
#  IN: asm.tokens
#      asm.tokens.len
# OUT: asm.bytecode
#      asm.bytecode.len
#      asm.constants
#      asm.constants.len
sub-procedure asm.tokens.to-bytecode
    call asm.tokens.find-labels
    store 0 in asm.pc
    while asm.pc is less than asm.tokens.len do
        store asm.tokens:asm.pc in asm.token
        if opcodes:asm.token is greater than 0 then
            store opcodes:asm.token in asm.bytecode:asm.bytecode.len
            add 1 and asm.bytecode.len in asm.bytecode.len
            store opsizes:opcodes:asm.token in asm.size
            if asm.size is greater than 0 then
                add 1 and asm.pc in asm.pc
                add asm.size and asm.pc in asm.size
                while asm.pc is less than asm.size do
                    store asm.tokens:asm.pc in asm.token
                    call asm.token.to-address
                    store asm.address in asm.bytecode:asm.bytecode.len
                    add 1 and asm.bytecode.len in asm.bytecode.len
                    add 1 and asm.pc in asm.pc
                repeat
                continue
            end if
        else
            store length of asm.token in asm.x
            subtract 1 from asm.x in asm.x
            get character at asm.x from asm.token in asm.char

            if asm.char is equal to ":" then
                # label
                store 0 in asm.bytecode:asm.bytecode.len
                add 1 and asm.bytecode.len in asm.bytecode.len
            else
                # number literals
                store asm.token in asm.bytecode:asm.bytecode.len
                add 1 and asm.bytecode.len in asm.bytecode.len
            end if
        end if

        add 1 and asm.pc in asm.pc
    repeat
end sub-procedure

# Converts a text of ASM source code to a text vector of tokens.
# Ignores comments and commas, upcases non-string tokens, strips
# extra whitespace, and supports strings with escaping.
#  IN: asm.input
# OUT: asm.lines
#      asm.lines.len
#      asm.tokens
#      asm.tokens.len
sub-procedure asm.input.to-tokens
    store length of asm.input in asm.len
    store 0 in asm.pc
    store 0 in asm.comment?
    store 0 in asm.string?
    store "" in asm.char
    store "" in asm.token
    store "" in asm.prev

    while asm.pc is less than asm.len do
        store asm.char in asm.prev
        get character at asm.pc from asm.input in asm.char

        if asm.string? is equal to 1 then
            if asm.char is equal to "\"" then
                if asm.prev is equal to "\\" then
                    # quoted string
                    join asm.token and asm.char in asm.token
                else
                    # not quoted, end string token
                    join asm.token and asm.char in asm.token
                    store asm.token in asm.tokens:asm.tokens.len
                    add 1 and asm.tokens.len in asm.tokens.len
                    store "" in asm.token
                    store 0 in asm.string?
                end if
            else
                # not a quote, add to token
                join asm.token and asm.char in asm.token
                join asm.line and asm.char in asm.line
            end if
            add 1 and asm.pc in asm.pc
            continue
        end if

        # treat commas as spaces
        if asm.char is equal to "," then
            store " " in asm.char
        end if

        if asm.char is equal to "\n" then
            # save line
            if asm.line is not equal to "" then
                store asm.line in asm.lines:asm.lines.len
                add 1 and asm.lines.len in asm.lines.len
                store "" in asm.line
            end if
            # save token
            if asm.token is not equal to "" then
                store asm.token in asm.tokens:asm.tokens.len
                add 1 and asm.tokens.len in asm.tokens.len
                store "" in asm.token
            end if
            store 0 in asm.comment?
        else if asm.char is equal to "\"" then
            # parse string
            store 1 in asm.string?
            store "\"" in asm.token
        else if asm.char is equal to ";" then
            # ignore comments
            store 1 in asm.comment?
        else if asm.char is equal to " " then
            # squash spaces
            if asm.prev is not equal to " " then
                if asm.prev is not equal to "\n" then
                    # add single space to line
                    join asm.line and asm.char in asm.line
                    # save token
                    if asm.token is not equal to "" then
                        store asm.token in asm.tokens:asm.tokens.len
                        add 1 and asm.tokens.len in asm.tokens.len
                        store "" in asm.token
                    end if
                end if
            end if
        else if asm.comment? is equal to 0 then
            # all tokens are UPPER case
            store asm.char in upcase.letter
            call upcase-letter
            store upcase.letter in asm.char
            # add char to token
            join asm.token and asm.char in asm.token
            # add char to line
            join asm.line and asm.char in asm.line
        end if
        add 1 and asm.pc in asm.pc
    repeat
end sub-procedure

#  IN: asm.input
# OUT: asm.bytecode
#      asm.bytecode.len
sub-procedure asm.input.to-bytecode
    call asm.input.to-tokens
    call asm.tokens.to-bytecode
end sub-procedure

#  IN: asm.input
# OUT: asm.textcode
#      asm.bytecode
#      asm.bytecode.len
sub-procedure asm.compile
    call asm.input.to-bytecode

    # assemble string constants
    store "" in asm.textcode
    store 0 in asm.pc
    while asm.pc is less than asm.constants.len do
        in asm.textcode join asm.textcode asm.constants:asm.pc " "
        add 1 and asm.pc in asm.pc
    repeat

    # L D P L header, version #, 1st instruction, string constants
    add 6 and asm.pc in asm.pc
    store asm.pc in asm.t
    if asm.pc is less than 10 then
        join "0" and asm.t in asm.t
    end if
    in asm.textcode join "76 68 80 76 01 " asm.t " " asm.textcode

    store 0 in asm.pc
    while asm.pc is less than asm.bytecode.len do
        store asm.bytecode:asm.pc in asm.x
        if asm.x is less than 10 then
            join asm.textcode and "0" in asm.textcode
        end if
        in asm.textcode join asm.textcode asm.x " "
        add 1 and asm.pc in asm.pc
    repeat
end sub-procedure

# Must be called after asm.compile.
#  IN: asm.textcode
sub-procedure asm.bytecode.print
    display asm.textcode crlf
end sub-procedure