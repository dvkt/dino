# === ASSEMBLER ======================================================
# The assembler converts text assembly code into dino bytecode.
DATA:
# IN:
assembler.input         is text

# OUT:
assembler.bytecode      is number vector  # bytecode
assembler.bytecode.len  is number
assembler.constants     is text vector    # text constants
assembler.constants.len is number
assembler.textcode      is text           # text (file) version of bytecod

# CONSTANTS:
assembler.text-offset   is number

# INTERNALS:
assembler.labels        is text vector
assembler.labels.len    is number
assembler.lines         is text vector
assembler.lines.len     is number
assembler.tokens        is text vector
assembler.tokens.len    is number
assembler.token         is text
assembler.label         is text
assembler.address       is number

# LOCALS:
assembler.line          is text
assembler.len           is number
assembler.i             is number
assembler.x             is number
assembler.t             is text
assembler.size          is number
assembler.char          is text
assembler.prev          is text
assembler.comment?      is number
assembler.string?       is number

PROCEDURE:
store 12288 in assembler.text-offset # 0x3000

# Convert tokens of ASM source code to memory address.
#  IN: assembler.token
# OUT: assembler.address
sub-procedure assembler.token-to-address
    get character at 0 from assembler.token in assembler.char
    if assembler.char is equal to "\"" then
        add assembler.text-offset and assembler.constants.len in assembler.address
        store assembler.token in assembler.constants:assembler.constants.len
        add 1 and assembler.constants.len in assembler.constants.len
    else if assembler.char is equal to "$" then
        store REGISTERS:assembler.token in assembler.address
    else if assembler.char is equal to "#" then
        # register ID
        store 0 in assembler.address
    else if assembler.char is equal to "%" then
        # variables
        store 0 in assembler.address
    else
        store assembler.token in assembler.address
    end if
end sub-procedure

# Converts text tokens to bytecode and text constants.
#  IN: assembler.tokens
#      assembler.tokens.len
# OUT: assembler.bytecode
#      assembler.bytecode.len
#      assembler.constants
#      assembler.constants.len
sub-procedure assembler.tokens-to-bytecode
    store 0 in assembler.i
    while assembler.i is less than assembler.tokens.len do
        store assembler.tokens:assembler.i in assembler.token
        if opcodes:assembler.token is greater than 0 then
            store opcodes:assembler.token in assembler.bytecode:assembler.bytecode.len
            add 1 and assembler.bytecode.len in assembler.bytecode.len
            store opsizes:opcodes:assembler.token in assembler.size
            if assembler.size is greater than 0 then
                add 1 and assembler.i in assembler.i
                add assembler.size and assembler.i in assembler.size
                while assembler.i is less than assembler.size do
                    store assembler.tokens:assembler.i in assembler.token
                    call assembler.token-to-address
                    store assembler.address in assembler.bytecode:assembler.bytecode.len
                    add 1 and assembler.bytecode.len in assembler.bytecode.len
                    add 1 and assembler.i in assembler.i
                repeat
                continue
            end if
        else
            store length of assembler.token in assembler.x
            subtract 1 from assembler.x in assembler.x
            get character at assembler.x from assembler.token in assembler.char

            if assembler.char is equal to ":" then
                # label
                store 69 in assembler.bytecode:assembler.bytecode.len
                add 1 and assembler.bytecode.len in assembler.bytecode.len
            else
                # number literals
                store assembler.token in assembler.bytecode:assembler.bytecode.len
                add 1 and assembler.bytecode.len in assembler.bytecode.len
            end if
        end if

        add 1 and assembler.i in assembler.i
    repeat
end sub-procedure

# Converts a text of ASM source code to a text vector of tokens.
# Ignores comments and commas, upcases non-string tokens, strips
# extra whitespace, and supports strings with escaping.
#  IN: assembler.input
# OUT: assembler.lines
#      assembler.lines.len
#      assembler.tokens
#      assembler.tokens.len
sub-procedure assembler.tokenize-input
    store length of assembler.input in assembler.len
    store 0 in assembler.i
    store 0 in assembler.comment?
    store 0 in assembler.string?
    store "" in assembler.char
    store "" in assembler.token
    store "" in assembler.prev

    while assembler.i is less than assembler.len do
        store assembler.char in assembler.prev
        get character at assembler.i from assembler.input in assembler.char

        if assembler.string? is equal to 1 then
            if assembler.char is equal to "\"" then
                if assembler.prev is equal to "\\" then
                    # quoted string
                    join assembler.token and assembler.char in assembler.token
                else
                    # not quoted, end string token
                    join assembler.token and assembler.char in assembler.token
                    store assembler.token in assembler.tokens:assembler.tokens.len
                    add 1 and assembler.tokens.len in assembler.tokens.len
                    store "" in assembler.token
                    store 0 in assembler.string?
                end if
            else
                # not a quote, add to token
                join assembler.token and assembler.char in assembler.token
                join assembler.line and assembler.char in assembler.line
            end if
            add 1 and assembler.i in assembler.i
            continue
        end if

        # treat commas as spaces
        if assembler.char is equal to "," then
            store " " in assembler.char
        end if

        if assembler.char is equal to "\n" then
            # save line
            if assembler.line is not equal to "" then
                store assembler.line in assembler.lines:assembler.lines.len
                add 1 and assembler.lines.len in assembler.lines.len
                store "" in assembler.line
            end if
            # save token
            if assembler.token is not equal to "" then
                store assembler.token in assembler.tokens:assembler.tokens.len
                add 1 and assembler.tokens.len in assembler.tokens.len
                store "" in assembler.token
            end if
            store 0 in assembler.comment?
        else if assembler.char is equal to "\"" then
            # parse string
            store 1 in assembler.string?
            store "\"" in assembler.token
        else if assembler.char is equal to ";" then
            # ignore comments
            store 1 in assembler.comment?
        else if assembler.char is equal to " " then
            # squash spaces
            if assembler.prev is not equal to " " then
                if assembler.prev is not equal to "\n" then
                    # add single space to line
                    join assembler.line and assembler.char in assembler.line
                    # save token
                    if assembler.token is not equal to "" then
                        store assembler.token in assembler.tokens:assembler.tokens.len
                        add 1 and assembler.tokens.len in assembler.tokens.len
                        store "" in assembler.token
                    end if
                end if
            end if
        else if assembler.comment? is equal to 0 then
            # all tokens are UPPER case
            store assembler.char in upcase.letter
            call upcase-letter
            store upcase.letter in assembler.char
            # add char to token
            join assembler.token and assembler.char in assembler.token
            # add char to line
            join assembler.line and assembler.char in assembler.line
        end if
        add 1 and assembler.i in assembler.i
    repeat
end sub-procedure

#  IN: assembler.input
sub-procedure assembler.compile
    call assembler.tokenize-input
    call assembler.tokens-to-bytecode

    store 0 in assembler.i
    while assembler.i is less than assembler.tokens.len do
        store assembler.bytecode:assembler.i in assembler.x
        if assembler.x is greater than assembler.text-offset then
            subtract assembler.text-offset from assembler.x in assembler.x
        end if
        if assembler.x is less than 10 then
            display "0"
        end if
        display assembler.x ": "
        display assembler.tokens:assembler.i crlf
        add 1 and assembler.i in assembler.i
    repeat

    display crlf "-------------------------" crlf

    store 0 in assembler.i
    while assembler.i is less than assembler.bytecode.len do
        display "\t"
        if assembler.bytecode:assembler.i is less than 10 then
            display "0"
        end if
        display assembler.bytecode:assembler.i "  "
        display "\t" assembler.tokens:assembler.i crlf
        add 1 and assembler.i in assembler.i
    repeat
    display assembler.tokens.len crlf
    display assembler.bytecode.len crlf
end sub-procedure